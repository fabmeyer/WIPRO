\documentclass[a4paper,10.2pt,pdftex]{scrartcl}%NEU
\usepackage[T1]{fontenc}
\usepackage[utf8x]{inputenc} 
\usepackage[english, ngerman]{babel}
\usepackage[babel,german=swiss]{csquotes}
\usepackage{listings}
\usepackage{ltxtable} 
\usepackage{tabularx}
\usepackage{tabu}
\usepackage{graphicx}
\usepackage{url}
\usepackage{longtable}
\usepackage{wrapfig,lipsum,booktabs}
\usepackage{scrpage2} 
\usepackage{listings}
\pagestyle{scrheadings}
\automark{section}
%\usepackage{natbib}
%\usepackage[notocbib]{apacite}
\usepackage[top=3cm,bottom=3.5cm,left=3.5cm,right=3.5cm]{geometry} 

\usepackage{lmodern}

\DeclareOldFontCommand{\sc}{\normalfont\scshape}{\@nomath\sc}
\lstdefinelanguage{JavaScript}{
  keywords={typeof, new, true, false, catch, function, return, null, catch, switch, var, if, in, while, do, else, case, break},
  keywordstyle=\color{blue}\bfseries,
  ndkeywords={class, export, boolean, throw, implements, import, this},
  ndkeywordstyle=\color{darkgray}\bfseries,
  identifierstyle=\color{black},
  sensitive=false,
  comment=[l]{//},
  morecomment=[s]{/*}{*/},
  commentstyle=\color{purple}\ttfamily,
  stringstyle=\color{red}\ttfamily,
  morestring=[b]',
  morestring=[b]"
}

\lstset{
  basicstyle=\ttfamily,
}

%\usepackage{mathptmx}% Times (gut)
%\usepackage{beraserif}% Bera (wohl eher ungeeignet)
%\usepackage{mathpazo}% Palatino (gut!)
%\usepackage{bookman}% Bookman (etwas altert¸mlich)
%\usepackage{charter}% Charter (gut!) NEU
\usepackage{newcent}% Newcentury (gut)
%\usepackage{utopia}% Utopia (gut bis gut!)
%%%%% Ende Einfuegung

\usepackage[scaled]{helvet}%NEU
%\renewcommand{\sfdefault}{\rmdefault}%NEU

\usepackage[german]{varioref}

\usepackage{setspace}
\onehalfspacing
%\linespread{1.07}

\usepackage{ellipsis}

% .....

\usepackage[multiple]{footmisc}
%\usepackage[multiple,perpage]{footmisc}

\usepackage[alwaysadjust]{paralist}
\setlength{\pltopsep}{1ex}

%\deffootnote[1em]{1em}{1em}{\textsuperscript{\thefootnotemark\ }}

\usepackage[pdftex,
colorlinks=false, pdfborder={0 0 0},
bookmarksopen=true,
hyperfootnotes=false,
]{hyperref}
 

% Sicheres "Vgl.:" um Tippfehler zu vermeiden
\newcommand{\f}{\footnote}
\newcommand*{\VGL}{Vgl.:}
%\renewcommand{\opcittext}{a.~a.~O} 
%\renewcommand{\idemtext}{Ebenda} 
\newcommand{\first}[1]{\emph{#1}}
\newcommand{\q}[1]{\iflanguage{ngerman}{\flqq#1\frqq}{``#1''}}
\newcommand{\qq}[1]{\iflanguage{ngerman}{\frqq#1\flqq}{``#1''}}
\newcommand{\qs}[1]{\iflanguage{ngerman}{\flq#1\frq}{``#1''}}
\newcommand{\z}{\cite}
\newcommand{\e}{\emph}
%\newcommand{\c}{ \z}

% Korrekturanmerkungen am Rand (fett-kursiv)
\newcommand{\notiz}[1]{\marginline{\textbf{\textit{\footnotesize #1}}}}


%\hyphenation{Ge-schmacks-po-ren Ge-schmacks-po-re aus-schliess-lich Atmo-sph‰-re}

% BIBLATEX ?
%Infos

%\usepackage{biblatex}
%\include{natbib
\usepackage{bibgerm}
%\usepackage{opcit}
%\usepackage[notocbib]{apacite}
%\renewcommand{\opcittext}{a.a.O.}
%\renewcommand{\idemtext}{Ebenda}
\hyphenation{Wahr-nehm-ungs-}
\usepackage{xcolor}
%\pagecolor[HTML]{dedede}
\begin{document}

\begin{titlepage} 
 \begin{center} 
    \thispagestyle{empty}
  {\small  Hochschule Luzern \hfill Institut für Informatik   \\[.75ex]
\hrule 
\vspace{0.75ex}
WIPRO  \hfill Herbstsemester 2019\\  

%\hfill FS 2010
% \hfill Proseminar
}

%{\small }

\vspace{14ex}



{\LARGE Wirtschaftsprojekt}


\vspace{2ex}

%Anzahl Zeichen
{\large \today}\\
\vspace{2ex}
%2\,500 Wörter

%\vspace{2ex}cv2.calcHist


\vspace{9ex}


{\huge\bfseries\textsf{Simulation und Visualisierung von \\[-1mm] Quantenkryptografie \\[5.5mm] }}

%\subtitle{}


\vspace{5ex}

%\vfill
Betreuungspersonen \\[2mm] Dr.\,Esther Hänggi \\ Dr.\,Halldór Janetzko\\[3mm]


\vspace{8ex}

{\Large Adrian Althaus \\[2mm] Fabian Meyer  \Large {}}

\vspace{8ex}

% {\large 17. M‰rz 2007}

 %\vspace{4ex}
 
%\vfill

\end{center}
\end{titlepage}

\vspace*{1ex}
\thispagestyle{plain}
\pdfbookmark{Inhalt}{toc}
\tableofcontents
\newpage
\section{Problem, Fragestellung, Vision}
\subsection{Quantenkryptografie: Das BB84-Protokoll} 
In der Quantenverschlüsselung werden sich Eigenschaften der Quantenphysik zunutze gemacht, um damit Informationen verschlüsseln zu können. Gleichzeitig ist es eine inhärente Eigenschaft eines quantenphysikalischen Systems, dass bei einem Messvorgang das System selbst gestört wird. Diese Eigenschaft wird genutzt, um ein mögliches Abhören einer Botschaft detektieren zu können.

Eine Möglichkeit, Informationen mithilfe eines quantenphysikalischen Systems zu übertragen, ist die Polarisierung von Photonen. Dabei werden Photonen mithilfe geeigneter Gerätschaft polarisiert und dann durch einen Lichtwellenleiter verschickt. Am anderen Ende kann der Empfänger die Polarisation durch den Einsatz von optischen Geräten rekonstruieren und so die originale Botschaft wiederherstellen.

Photonen können in 4 möglichen Zuständen polarisiert werden: 0°, 45°, 90° und 135°. Dabei stellen 0° und 90° gerade Polarisierungen dar und 45° und 135° diagonale Polarisierungen. Ein Bit kann nun in 2 möglichen Polarisierungen kodiert werden: 0 mit 0° oder 45° und 1 mit 90° oder 135°. Nur durch das Wissen der Polarisierung und der richtigen Basis kann das korrekte Bit bestimmt werden.

Ist das Protokoll erfolgreich durchgeführt worden unter Einhaltung von gewöhnlichen Sicherheitsvorkehrungen, können der Sender und der Empfänger erfolgreich einen Schlüssel generieren, mit dem sich Informationen ähnlich einem one-time pad (symmetrisch) verschlüsseln können. 

Ein weiterer, wichtiger Vorteil von Quantenverschlüsselung im Gegensatz zu konventioneller (asymmetrischer) Verschlüsselung ist, dass die Etablierung des Schlüssels auf physikalischen Eigenschaften beruht und nicht auf mathematischen Berechnungen wie beispielsweise Hashfunktionen. Diese physikalischen Eigenschaften lassen sich auch mit erhöhtem Rechenaufwand nicht umgeghen. Ebenso arbietet man in der Quantenverschlüsselung weitgehend mit probabilistischen Verfahren. Aufgrund von quantenphysikalischen Eigenschaften ist ein Abfangen von Photonen zwar grundsätzlich feststellbar, aber letzten Endes bleibt für Sender und Empfänger lässt sich die Frage, ob Photonen abgehört wurden, nur mit einer bestimmten Wahrscheinlichkeit beantworten. 


\subsubsection{BB84 Protokoll}
Das BB84-Protokoll, benannt nach seinen Erfindern, Charles Bennet und Gilles Brassard, und seinem Veröffentlichungsjahr 1984, ist das bekannteste Protokoll zur Realisierung einer Quantenverschlüsselung. Es soll hier kurz beschrieben werden.

Der Einfachheit halber gehen wir von 3 Personen aus: Alice, welche die Nachricht verschickt, Bob, welche sie empfängt und Eve, welche die Nachricht abhören möchte.

Ablauf:
\begin{enumerate}
\item Alice erzeugt einen zufälligen, genügend langen Bitstring
\item  Diesen Bitstring enkodiert Alice, indem sie für jedes Bit eine zufällige Basis wählt (gerade oder diagonal) und damit jedes Photon polarisiert
\item  Die polarisierten Photonen schickt Alice mithilfe eines optischen Mediums (in der Regel ein Glasfaserkanal) an Bob
\item  Wenn Bob die Photonen erhält, misst er die Polarisierung jedes einzelnen Photons mithilfe seiner zufällig gewählten Basis (gerade oder diagonal) und dekodiert so den Bitstring
\item  Durchschnittlich sollte Bob zu 50\% die richtige Basis wählen und daher das korrekte Bit (0 oder 1) zu 50\% rekonstruieren können
\item  Bob befragt nun Alice (über einen authentisierten, öffentlichen Kanal) über die Basis jedes einzelnen Photons
\item Jedes Bit, welches durch eine falsch gewählte Basis bestimmt wurde, wird gekürzt. Das heisst der Schlüssel wird durchschnittlich 50\% kürzer
\item  Zum jetzigen Zeitpunkt sollten Alice und Bob denselben, identischen Bitstring besitzen, dieser wird auch \q{sifted key} genannt
\item  Alice und Bob können über einen authentisierten, öffentlichen Kanal ein Teil des Bitstrings miteinander vergleichen, um sicherzugehen, dass sie nicht abgehört wurden
\item  Dieser Teil wird dann verworfen. Der restliche Teil bildet den \q{shared secret key}
\item  Falls Eve die Nachricht abhören will, muss sie die Polarisierung der Photonen zwischen Alice und Bob messen. Auch Eve muss daher eine zufällig generierte Abfolge von Basen (gerade und diagonal) verwenden, um die Polarisation zu messen
\item  Wenn Eve eine falsche Basis gewählt hat, wird die Polarisierung des jeweiligen Photons aufgrund zufälligerweise neu gesetzt
\item  Falls Eve alle Bits gemessen hat, sinkt die Wahrscheinlichkeit, dass Eve unentdeckt bleibt nach $n$ verglichenen Bits auf $(\frac{3}{4})^n$. Mithilfe von statistischen Tests kann überprüft werden, ob ein Mithörer die Photonen abgehört hat oder nicht
\item  Falls ein Mithörer vorhanden war, wird das Protokoll wiederholt
\item  Durch ein Absprechen können Alice und Bob eine andere Basenverteilung von geraden und diagonalen Basen als 50/50 benutzen. Dies führt zu längeren Schlüsseln bzw. weniger Kürzung
\end{enumerate}

\subsubsection{Kompromiss aus Simulation und Visualisierung des BB84-Protokolls}
Die Fragestellung, wie man ein solch komplexen Sachverhalt simulieren und gleichzeitig visualisieren könnte, war die Ausgangsstellung dieses Projektes. Von Anfang an gab es einen grossen Spielraum und Freiheit bei der Konzeption und Umsetzung. Da die beiden Autoren dieses Projektes beide einen anderen Background haben (Frontend bzw. Backend), kristallisierte sich langsam ein Konzept heraus, welches eine relativ klare Aufgabenteilung beinhaltete.

Für die Simulation bietet sich natürlich ein Backend an, bei welcher Performance und Robustheit oberste Priorität hat. Auf der anderen Seite kann die Visualisierung nur in einem Frontend sinnvoll verwirklicht werden, da hier mithilfe des Einsatz von Text, Bild und weiteren Medien die Thematik dem Benutzer erklärt werden kann.

Dies führte zu der Idee, eine Webapplikation zu programmieren, welche beide Anwendungen miteinander verbindet. Diese Verbindung führte zu einem bedingten Kompromiss: Das Backend generiert Daten für eine Simulation von quantenkryptografischer Verschlüsselung, bei welcher üblicherweise sehr grosse Datenmengen verarbeitet werden. Das Frontend hingegen muss den Sachverhalt möglichst einfach erklären können. Dazu sind keine grossen Datenmengen nötig. Die Daten werden für die Visualisierung über eine REST-Schnittstelle geladen. 

Dieser Kompromiss sollte erreicht werden, indem dem Benutzer trotzdem das Gefühl gegeben wird, dass hier sehr grosse Mengen von Daten verarbeitet werden und der Benutzer einen Einblick in die Komplexität der Thematik erhält. 
 



\subsection{Schwerpunkte}
Durch die Unterteilung in Frontend und Backend und deren Zuweisung an eine Person ergeben sich in beiden Bereichen unterschiedliche Schwerpunkte. Beim Frontend geht es im Wesentlichen um die Darstellung der Simulation der einzelnen Schritte des BB84-Protokolls, um diesen Prozess für den Benutzer möglichst lehrreich, intuitiv und ästhetisch befriedigend visualisieren zu können. Dies beinhaltet die die Repräsentation der einzelnen Komponenten der Simulation von Quantenkryptografie als UI-Elementen. Das Frontend soll vom User interaktiv bedienbar sein, um so die Erzeugung der Schlüssel der Quantenkryptografie auf geeignete Weise beeinflussen zu können.

Das Backend übernimmt die Abbildung der physikalischen Vorgänge der Quantenkryptografie als einzelne Komponenten, die über Schnittstellen miteinander verbunden sind.  und welche zu einem späteren Zeitpunkt mühelos erweitert, ausgetauscht und angepasst werden können. Die Simulation soll schlussendlich über eine API von aussen benutzbar, konfigurierbar und abgreifbar sein mit einem Bytestream als Output.

Unabhängig von der Umsetzung und Arbeitsteilung bildet ein Schwerpunkt die Erlangung der nötigen Kenntnisse, die für ein vertieftes Verständnis des BB84-Protokolls erforderlich sind.

\section{Stand der Praxis}
\subsection{Frontend / Informationsvisualiserung}
In den letzten Jahren haben sich die Möglichkeiten in der Datenvisualisierung rasant verändert. Gleichzeitig findet eine Verschiebung von statischer Berichterstattung mit Text und Bild zu dynamischen, interaktiven Multimediaformen statt.

Beispielsweise hat die Onlineausgabe der \emph{New York Times} seit dem Jahr 2014 eine neue Sparte namens \q{The Upshot}\footnote{\url{https://www.nytimes.com/section/upshot}}, auf welcher Artikel veröffentlicht werden, die politische, wirtschaftliche oder gesellschaftliche Themen durch den Einsatz von Techniken der Datascience und Datenvisualierung ergänzen, sogenanntes \q{data-driven storytelling} aufwerten. Diese Artikel sind dynamisch und interaktiv; der Benutzer kann die Daten manipulieren und so direkt in die Visualierung eingreifen.

Möglich macht dies Fortschritte nicht nur die Produktion leistungsfähigerer Computerhardware, sondern auch die Entwicklung von immer leistungsfähigerer Browsersoftware. Dabei findet eine stetige Verschiebung von Rendering auf der Serverseite zum Rendering auf der Clientseite statt. Wo früher grosse Mengen von Daten nur auf hochspezialiserten Computer berechnet und visualisiert werden konnten, kann dies heutzutage auch auf einem PC im Browser realisiert werden. Daher erstaunt es nicht, dass auch spezialisierte Datenvisualierungsbibliotheken, wie D3 für die clientseitige Scriptsprache JavaScript zur Verfügung stehen.

\subsection{Explorable Explainables}
Im letzten Jahrzehnt sind einige Tools, Frameworks, Markupsprachen oder Bibliotheken erschienen, welche sich darauf spezialisieren, Techniken der Datenvisualisierung zu benutzen, um so dynamischen, interaktiven und multimedialem content zu erzeugen. Diese unterscheiden sich jedoch gross in Bezug auf die Voraussetzungen des angesprochenen Benutzers (Informatik-Hintergrund oder Autor bei einer Zeitung) oder Domäne (spezialiserte Software oder allgemein einsatzfähig).

Diese Art von Software, welche Berichterstattung mit interaktiven Techniken der Datenvisualierung kombiniert wird als \emph{Explorable Explainables} bezeichnet. Die Abgrenzung zu anderer Software ist nicht ganz eindeutig, beispielsweise kann auch Project Jupyter verwendet werden, um Daten interaktiv zu visualisieren und dies einer grossen Audienz zugänglich zu machen. Jedoch verlangen Jupyter notebooks sehr viel Vorkentnisse in der Informatik und sind daher auf eine bestimmte Zielgruppe beschränkt. 
\subsection{Idyll}
Eine dieser Markupsprachen ist Idyll \footnote{\url{https://idyll-lang.org}}, welche die Erzeugung interaktiver Dokumente mit der Markupsprache Markdown verbindet. Idyll stellt eine Reihe von UI-Komponenten zur Verfügung, mit welchen sich einerseits Inhalte wie Text, Bild und Visualisierungen darstellen lassen, als auch Komponenten wie Regler, Eingabefelder und weitere, um Daten zu manipulieren.

Idyll selbst basiert auf der UI-Bibliothek React \footnote{\url{https://reactjs.org}}, welche anfänglich von Facebook entwickelt wurde und im Jahr 2013 als open-source Projekt der Öffentlichkeit zugänglich gemacht wurde. Die Philosophie von React beruht einerseits auf der Entwicklung von Komponenten mit Schnittstellen, die wiederverwendet werden können und andererseits auf der reaktiven Programmierung, ein relatives neues Programmierparadigma, welches Zustände und Änderungen einzig und allein auf Datenflüsse zurückführt. React eignet sich insbesonders um single-page Applications (SPAs) zu erzeugen. Dabei wird bei einem Seitenaufruf nur eine leere Hülle aus HTML geladen und der gesamte content wird beim client im Browser dynamisch durch JavaScript erzeugt (server-side Rendering, SSR).

Idyll verknüpft die einfache Herstellung von Komponenten von React mit dem simplen Markupsyntax von Markdown, mit welchem sich rasch einfache Dokumente schreiben lässt. Ähnlich wie bei LaTeX, wird bei Markdown Inhalt und Struktur gegenüber Layout getrennt. Das Layout kann einfach mit einer CSS-Datei gesteuert werden.

In Idyll wird also der einfache Syntax zum Schreiben von Texten mit Markdown mit dem System zur Erzeugung von Komponenten von React verknüpft. Bei der Kompilation werden gewöhnliche JavaScript-, HTML- und CSS-Dateien erzeugt, welche statisch auf einem Server abgelegt werden können.
\subsection{Vergleichbare Projekte}
Es existieren wenige Projekte, welche sich zum Ziel gemacht haben, das BB84-Protokoll oder Quantenverschlüsselung allgemein zu simulieren und visualisieren. 

Eines davon ist von Fred Henle aus dem Jahr 2008\footnote{\url{http://fredhenle.net/bb84/demo.php}}, welches das BB84-Protokoll auf eine spielerische Weise erklärt. Wie man rasch erkennt, ist es schon ein bisschen in die Jahre gekommen und entspricht nicht mehr dem Verständnis und Aussehen moderner Webseiten. Trotzdem ist es auf der englischsprachigen Wikipediaseite \footnote{\url{https://en.wikipedia.org/wiki/Quantum_key_distribution}} zu \emph{Quantum key distribution} aufgelistet.

Ein nennenswertes Beispiel ist auch der \emph{Quantum Computing Playground} \footnote{\url{http://www.quantumplayground.net/\#/home}}, mit welchem sich die Programmierung von Qubits mithilfe von Quantengates simulieren lässt. Obwohl sehr leistungsfähig (die Grafiken werden mit WebGL gerendert) und wissenschaftlich exakt, ist es nicht der Anspruch dieser Seite, eine solch komplexe Thematik auf einfache und verständliche Art und Weise erklären zu wollen.

Eine erschöpfende Liste von Software, welche sich primär mit Quantumcomputing befasst oder diese simuliert findet man auf Quantiki\footnote{\url{https://www.quantiki.org/wiki/list-qc-simulators}}, dem bekanntesten Informationsportal zu allen Themen der Quanteninformationstheorie und deren Anwendungen.
% Backend: Event getrieben vs Simulation getrieben. 

\subsection{Modularisierung}
% Backend: Event getrieben vs Simulation getrieben. 
Modularisierung ist ein grundlegendes Prinzip der Softwaretechnik. Sie hilft bei der Komplexitätsreduktion und erhöht die Flexibilität von Software. Unterteil man Software in verschiedene Module, so geschieht dies nach gängigen Kriterien wie minimale Schnittstellen, maximale Bindung, minimale Koppelung oder Testbarkeit. In Falle einer Simulation mit physikalischen Komponenten liegt es nahe, die einzelen Komponenten als in sich geschlossenes Modul zu betrachten. In Java geschieht dies auf technischer Ebene mit Interfaces. Damit eine Klasse zum Modul wird, muss sie richtig konzipiert sein. Unterstützend wirken Pakete und JARs, die aber keine Zugriffskontrolle über eine Schnittstelle kennen. Vor Java 9 war eine echte Modularisierung nur mit \emph{Open Services Gateway} (OSGi) möglich, welche aber nicht Teil des Standardumfangs von Java ist \cite[S. 32f]{modul}
\subsubsection{Modularisierung mit Java 9} 
Mit dem lange erwarteten Projekt \emph{Jigsaw} es eine explizite Erstellung von Modulen möglich. Sie können aus einem oder mehreren Paketen bestehen, und die Sichtbarkeiten und Abhängigkeiten sind klar definiert. So lassen sich gleichsam verschachtelte Modulabhängigkeiten und transitive Abhängigkeiten verwirklichen. Ein Modul besteht aus einem Namen, einer Schnittstelle und natürlich der Implementierung. Im Zuge von Jigsaw wurde auch das JDK in eine Vielzahl von Modulen aufgeteilt\cite[S. 863]{inden}. 
\begin{table}
\begin{tabular}{ll}
\texttt{exports} & Öffentlich zugänglich gemachte Pakete \\
\texttt{requires} & Liste importierbarer Module \\
\texttt{uses / provides} & Benötigter und angebotener \emph{service} \\
\texttt{opens} & Zugriff über Reflection erlauben
\end{tabular} 
\caption{Jigsaw Keywords}
\end{table}
Skalierbarkeit der Jva-Plattform, Erhöhung der Sicherhiet, Startup-Performance, Unterstüztung beim entwur fmodularer und gut wartbarer Anwendungen und Bibliotheken. 

\subsubsection{Entscheid}
Keine Modulhierarchien 


\section{Ideen und Konzepte}
Aus der Aufgabenstellung geht hervor, dass sich das Projekt zum einen gewissen didaktischen Anforderunge erfüllen muss, zum anderen die Einbettung in bestehende Systeme am Departement für Informatik zu berücksichtigen hat. Insofern wurden Ansätze einer monolithischen Applikation bereits bei den ersten Überlegungen verworfen. Vielmehr hatte sich rasch herauskristallisiert, dass die unterschiedlichen Anwendungsfälle am besten mit einem modularen Kernsystem abgedeckt werden, die dann entweder in einem diaktischen Kontext als Webapplikation, oder dann eben im produktivem Einsatz beispielsweise als CLI-Tool eingebunden werden. Dadurch lässt sich das Projekt zudem in ein Frontend und Backend einteilen, für die dann -- abhängig von den jeweiligen Präferenzen --  je einer der beiden Projektpartner zugewiesen werden können. Zum Projektstart hat man sich auf eine Modellierung geeinigt, die das BB84-Protokoll physikalisch in einer Webapplikation abbildet, wobei es zu der jeweiligen physikalischen Komponente je eine Entsprechung im Frontend und Backend gibt, die miteinander interagieren. Der Ablauf der BB84-Protokoll wird somit in Teilschritte gegliedert, die unabhängig voneinander atomar ausgeführt werden können. Bei jedem dieser Teilschritte wird die REST-Schnittstelle mit den benötigten Parametern angesteuert. Das Backend arbeitet damit stateless. 

\subsection{Alternative Ideen}
Die offene Aufgabenstellung und die Zielsetzung lassen viele Freiheiten bei der Konzeption des Projekts zu.

Da die beiden Autoren jedoch unterschiedliche Ausrichtungen und Fähigkeiten besitzen (Frontend vs. Backend), hat sich ein Konzept angeboten, welche auf der Frontendseite die Visualierung und auf der Backendseite die Logik umsetzt. Für das Backend sollen Module entwickelt werden, die in unterschiedlichen Kontexten eingebunden werden können. Dies erschien als die sinnvollste Lösung für die beiden unterschiedlichen Anwendungszwecke.  Dieser Ansatz stand rasch fest. Die Kombination aus Idyll und Java-Backend musste sich erst herauskristallisieren. Für Java sprach die Unterstützung von Modularisierung ebenso wie der Aspekt der Performance. Darüber hinaus wird Java an der Hochschule Luzern unterrichtet. Idyll machte mit Blick auf die Idee eines interaktiven Papers einen überzeugenden Eindruck. Dennoch haben stand Python als Backendlösung zur Debatte. 

Hinsichtlich der Kommunikation zwischen Frontend und Backend war es lange nicht ganz eindeutig, inwiefern das Backend Kenntnisse über den Zustand des Frontends haben sollte. Versuchsweise wurde deshalb für die Zwischenspeicherung von berechnetetn Werten auf dem Server eine Unterstützung für Sessions eingebaut. Das Frontend beinhaltete in einer früheren Version einen Settings-Button, der Parameter, die bei mindestens zwei unterschiedlichen physikalischen Komponenten benötigt werden, an den Server für eine Ablage in der Session sendet. Im weiteren Projektverlauf wurde dieser Ansatz verworfen, weil sich die Anzahl Parameter wie auch die Datengrösse der Payloads im jeweiligen Requests in Grenzen hielt. Die Verbindung einer REST-Schnittstelle und Sessions erschien dann quasi als Antipattern, da REST einerseits für ein zustandsloses Paradigma steht. Und ein zustandsloses Backend macht grundsätlich Sinn, da sich atomare Ausführungseinheiten besser parallelisieren oder gar auslagern lassen, etwa in eine Cloud als Function-as-a-Service. Und wenn das Zusammenspiel mit dem Frontend zustandslos funktionert, wird es dies bei der Einbindung der Komponenten in anderen Kontexten sowieso tun. 

\section{Realisierung}
\subsection{Architektur}
Die Aufgabenstellung verlangt eine Art Zweiteilung der Programmierarbeiten. Die Umsetzung der physikalischen Komponenten ist zunächst einmal unabhängig vom Einsatzzweck. Bei den beiden Anwendungsfällen aber werden sie auf unterschiedliche Weisen angesprochen. Bei der Vermittlung des BB84-Protokolls an interessierten Personen kommt ein interaktives Webfrontend zum Zuge, das über eine REST-Schnittstelle mit dem Java-Backend kommuniziert. Die eigentlichen Komponenten können als Java-Kompontenten angesprochen werden. 
\subsubsection{Das modulare Prinzip}  
\subsubsection{Client-Server Architektur}

\subsection{Frontend}
Das Frontend wurde mithilfe von Idyll und React umgesetzt. Die Grundstruktur eines idyll-Projektes besteht aus einem index.idyll file und einem Ordner mit allen Komponenten. Das index.idyll file ist vergleichbar mit einem HTML-file, welches für die Struktur des Dokumentes zuständig ist. In dieses file wird dann der gesamte Text und alle Komponenten eingebunden.
\subsubsection{Verwendete Idyll-Komponenten}
Idyll bringt eine Reihe von Komponenten mit, die jedoch alle ziemlich simpel sind und von welchen nicht gross Gebrauch gemacht wurde. Einzige Ausnahmen sind:

\begin{tabularx}{\textwidth}{p{2.5cm}p{11cm}}
Header & Der header der Webseite, mit allen wichtigen Informationen.\\
var & Eine Input-Komponente, mit der man eine Variable definieren kann. \\
fullWidth & Eine Komponente, welche als Wrapper benutzt wird, um den inneren Komponenten auf die ganze Seitenbreite zu rendern. \\
Equation & Eine Komponente, welche es ermöglicht LaTeX-Syntax direkt im index.idyll-file zu schreiben. \\
Display & Eine Komponente, welche den Wert einer Variable anzeigt, mit zusätzlichen Möglichkeiten der Formatierung.
\end{tabularx}

\subsubsection{Verwendete npm packages}
\begin{tabularx}{\textwidth}{p{3cm}p{11cm}}
react-arrow &  Ein package, welches einen Komponenten ausgibt, der einen Pfeil als canvas-Element rendert. \\
react-anime &  Ein package, welches einen Wrapper um die JavaScript-Bibliothek animejs bildet. Damit lassen sich Animationen generieren, indem man für verschiedene Keyframes Werte eines bestimmten properties eingibt. \\
react-emoji-render &  Ein package, mit welchem sich einfach ein emoji darstellen läst. \\
react-rough &  Ein package, welches einen Wrapper um die JavaScript-Bibliothek roughjs bildet, mit der man Grafiken als canvas oder svg rendern kann, die einen handgemalten Stil besitzen. Sämtliche Grafiken in der Applikation wurden mit diesem package erstellt. \\
react-slider&  Ein package, mit welchem sich einfach ein Regler rendern lässt und bei dem man alle grafischen  Details per css genau steuern kann. Dieses package wurde verwendet um alle Regler im Dokument zu erstellen. \\
rodal&  Ein package, welches ein Modal (ein kleines Fenster, welches alles andere im Hintergrund verblasst)  rendert.

\end{tabularx}

\subsubsection{Arten von Komponenten}
\begin{tabularx}{\textwidth}{p{3cm}p{11cm}} 
Visuelle Komponenten &  Sind Komponenten, die Sachverhalte visuell darstellen, um sie so dem Benutzer veranschaulicht erklären zu können. \\
Logik-Komponenten & Sind Komponenten, die für die Logik des Frontends gebraucht werden, um den Ablauf des Algorithmus darstellen zu können. Sie sind entweder mit dem backend via der REST-API verbunden oder benutzen eine interne Logik, welche nur für das frontend von Bedeutung ist. \\
Input-Komponenten & Sind Komponenten, die der Benutzer bedienen kann, um den Programmablauf zu steuern.
\end{tabularx}
\subsubsection{Erstellte Komponenten} 
\begin{description}
\item[SystemOverview] Eine visuelle Komponente, die dazu dient dem Benutzer schon früh im Dokument eine Übersicht über das BB84-Protokoll zu geben und ihm die Möglichkeit zu geben, wichtige Einstellungen der Simulation festlegen zu können. Sie zeigt die drei Teilnehmer des Algorithmus, Alice, Bob und Eve, sowie die zwei Übertragungskanälen samt den einstellbaren Parameter.
\begin{figure}[h]
	\centering
  \includegraphics[width=\textwidth]{graphics/component_system_overview.png}
	\caption{System overview}
\end{figure}
\item[ButtonAliceStart] Eine Logik-Komponente, welche einen Button rendert, der den Algorithmus startet. Dabei wird die \texttt{strLength} zusammen mit \texttt{AliceProb} per POST-Methode an das Backend geschickt, um damit Alices Bitstring und ihre Base zu berechnen. Als Antwort kommt dann der Bitstring und die Base zurück.
\item[PhotonGridDouble] Eine visuelle Komponente, welche zwei Strings entgegennimmt und diese rendert als zwei Raster von einzelnen Symbolen. Der Hintergrund des Rasters kann bei Bedarf gefärbt werden (was am Schluss auch gemacht wird). Diese Komponente wird benutzt um zwei Strings (Bitstring oder Base) darzustellen. Per Klick auf das Raster öffnet sich ein Modal, welches den String in einem quadratischen Fenster darstellt (Komponente ScrollBox). 
\begin{figure}[h]
	\centering
  \includegraphics[width=0.5\textwidth]{graphics/component_photon_grid_double.png}
	\caption{Photon grid double}
\end{figure} 
\item[scrollBox] Eine visuelle Komponente, welche einen String in einem quadratischen Fenster darstellt. Es besitzt einen Slider, mit dem man die Schriftgrösse des Keys anpassen kann. Wird die Schriftgrösse zu klein, wechselt die Darstellung des Schlüssels von Text zu einem Bitmuster. Es existiert eine kleine Legende, welche die Farben des Bitmusters erklärt.
\begin{figure}[h]
	\centering
  \includegraphics[width=0.5\textwidth]{graphics/component_scroll_box.png}
	\caption{Scroll Box}
\end{figure}
\item[InformationBox] Eine visuelle Komponente, welche eine Tabelle rendert, die den für das Verständnis wichtigen Zusammenhang zwischen Bitstring, Base und resultierende Polarisation veranschaulicht.
\begin{figure}[h]
	\centering
  \includegraphics[width=0.5\textwidth]{graphics/component_information_box.png}
	\caption{Information Box}
\end{figure}
\item[SimpleSlider] Eine kleine Input-Komponente, welche nur einen Regler rendert, der genau ein property beeinflusst. 
\begin{figure}[h]
	\centering
  \includegraphics[width=0.4\textwidth]{graphics/component_simple_slider.png}
	\caption{Simple slider}
\end{figure}
\item[ButtonEmitPhotons] Eine Logik-Komponente, welche einen Button rendert, der den Algorithmus weiterführt. Damit wird aus dem Bitstring und der Base von Alice ein String von Polarisationen berechnet. Der Bitstring und die Base werden wieder per POST-methode an das backend geschickt und als Antwort kommt ein String von Polarisationen für Bob zurück.
\begin{figure}[h]
	\centering
  \includegraphics[width=0.4\textwidth]{graphics/component_button_emit_photons.png}
	\caption{ButtonEmitPhotons}
\end{figure}
\item[ShowHide] Eine kleine Logik-Komponente, welche als Wrapper dazu dient eine innere Komponente mithilfe einer Bedingung ein- oder ausblenden zu können. So können zum Beispiel Visualisierungen oder Animationen nach Bedarf eingeblendet werden.
\item[AnimationEmit] Eine visuelle Komponente, welche darstellt, dass Photonen von Alice zu Bob geschickt werden
\begin{figure}[h]
	\centering
  \includegraphics[width=\textwidth]{graphics/component_animation_emit.png}
	\caption{AnimationEmit}
\end{figure}
\item[ButtonBobBase] Eine Logik-Komponente, welche durch die Stringlänge und die Wahrscheinlichkeit der Basenverteilung von Bob eine Base für Bob berechnet. Die Stringlänge und die Wahrscheinlichkeitsverteilung werden per POST-methode an das backend geschickt, welches als Antwort eine Base für Bob zurückschickt. 
\begin{figure}[h]
	\centering
  \includegraphics[width=0.8\textwidth]{graphics/component_button_bob_base.png}
	\caption{ButtonBobBase}
\end{figure}
\end{description}


\subsection{Physikalische Komponenten}
Im Backend sind die physikalischen Komponenten verwirklicht, welche je durch eine eigene Klasse repräsentiert werden. Die Anzahl Komponenten wie auch deren Attribute sind gegeben durch die erreichten Funktionalitäten in der Umsetzung des BB84-Protokolls. Den Komponenten entspricht in der Regel eine Komponente im Frontend, jedoch kann ein Schritt in der Durchführung mehrere Komponente involvieren. Folgende Komponenten sind umgesetzt. 
\subsubsection*{RandomBitString}
Generiert einen Bitstring der Länge n
\begin{itemize}
\item Länge: n
\item Wahrscheinlichkeitsverteilung: Wahrscheinlichkeit von 0 oder 1
\end{itemize}
\subsubsection*{RandomBase}
Generiert eine Base 
\begin{itemize}
\item  Länge: n     
\item  Wahrscheinlichkeitsverteilung: Wahrscheinlichkeit von Rückgabewert rectilinear im Gegensatz zu Rückgabewert diagonal
\end{itemize}

\subsubsection*{PhotonEmitter}
Schickt eine Reihe von Photonen 
\begin{itemize}
\item  Länge: n
\item  Base: Liste von gewählten Basen
\item  Polarisierung: Liste von Polarisierung (Winkel)
\end{itemize}

\subsection{Channel}



\subsubsection*{PhotonReceiver}
\begin{itemize}
\item  Ungenaugkeit der gemessenen Polarisierung (falscher Winkel gemessen, 0 - 100\%) 
\item  Prozentsatz falsche Messung (nichtexistentes Photon gemessen)
\item  Prozentsatz fehlgeschlagene Messung (Photon bleibt unbemerkt)
\end{itemize}
\subsubsection*{ Übertragungskanal}
\begin{itemize}
\item  Verlustrate (Photon geht verloren)
\item  Noise (Polarisierung verändert sich, 0 - 100%)
\end{itemize}

\subsubsection*{ Comparator}
\begin{itemize}
\item Basis / Bitstring 1
\item Basis / Bitstring 2
\end{itemize}
\subsubsection*{ Eavesdropping}
\begin{itemize}
\item  Basis
\end{itemize}

\subsection{Ablauf}
\section{Vorgehensmodell}
Aufgrund der Aufgabenstellung empfiehlt sich ein hybrides Vorgehensmodell nach SODA. Ein Wasserfallmodell ist aus dem einfachen Grund ausgeschlossen, dass zum Zeitpunkt des Projektstarts der genaue Projektumfang noch nicht vorlag. Das Minimalziel liegt in der Umsetzung der Minimalanforderung, i.e. ein Schulbeispiel des BB84-Prototkolls. Die weiteren Punkte während der Projektverlaufs fortwährend festgelegt. 


\subsection{Architektur}
\subsubsection{Frontend}
\subsubsection{Backend}
Im Backend residiert ein Tomcat-Server. 
\subsection{Deployment}
Die ganze Applikation ist als Docker-Image verfügbar. Die Installation setzt also einen Docker-Client und eine Unix / Linux-Maschine voraus. Danach kann das Skript \texttt{install-docker.sh}-File ausgeführt werden. 

\section{Evaluation, Testing und Validation}
\subsection{Automatisierte Tests}
\subsection{Usertests}
\section{Ausblick}
\subsection{ Realistischere Simulation des BB84-Protokolls}

Um das BB84-Protokoll realistischer darstellen zu können, müsste man auf jeden Fall die Möglichkeit zur Verfügung stellen, dass der Photonenemitter Photonen zu viel oder zu wenig aussendet und dass der Photonendetektor Photonen zu viel oder zu wenig detektiert. Dies führt jedoch automatisch zu einer Veränderung der Länge und einer Verschiebung der jeweiligen Strings von Polarisationen (und Bits) von Alice und Bob. Damit dieses feature realisiert werden kann, muss jedoch gezwungenermassen ein timestamp mitgeschickt werden, mit dem jedes Photon datiert wird. Nur so können Alice und Bob Gewissheit haben, ob das jeweilige Photon ausgesendet und auch angekommen ist.

Weiterhin müssten Prozesse wie Rauschen (noise) oder Abhören (eavesdropping) als zeitabhängige, anstatt rein stochastische Prozesse implementiert werden. Das heisst, dass Rauschen und Abhören nicht mit einer konstanten Rate auftritt, sondern mit zeitabhängigen Variabeln modelliert werden sollte. Beispielsweise tritt Rauschen dann plötzlich auf (sogenannte "bursts") und flacht dann wieder ab. Und Eve wird möglicherweise nur ein Teil der Übertragung (dafür alle Photonen davon) messen, anstatt ein Verhältnis der gesamten Übertragung.

\subsection{Frontend}

Bei mehr verfügbarer Zeit wären im frontend die folgenden Verbesserungen implementiert worden:
\begin{itemize}
\item Die Systemübersicht wäre um die realistischeren features, wie oben beschrieben ergänzt worden. Diese könnten mithilfe von Regler am jeweiligen Ort einfach dargestellt werden.
\item Eine verkleinerte Darstellung der Systemübersicht (eine Art minimap) sollte dem User jederzeit eingeblendet werden, um den Standpunkt im Ablauf des Algorithmus zu visualisieren. Diese wäre beispielsweise in der oberen rechten Ecke platziert und würde nicht im Dokument mitscrollen. Darauf könnten dann die jeweiligen Komponenten, welche gerade im Algorithmus eine Rolle spielen farblich hervorgehoben werden.
\item Ein Plot am Ende des Dokumentes, vor der Konklusion könnte verwendet werden, um die Länge des common shared keys vs. der Länge des anfänglichen Bitstrings von Alice zu plotten. Damit könnte man visualisieren, wie sich die Wahl der Basen, das Rauschen und das Abhören auf die Länge des resultierenden Strings auswirken. Die Realisierung könnte mit einer Bibliothek, wie D3.js erfolgen.
\item Im Verlauf des Dokuments sollte dem User mehr feedback gegeben werden, damit die App sich interaktiver präsentiert und sich der Ablauf des Algorithmus weniger atomar anfühlt.
\end{itemize}
\subsection{API}
\subsection{Backend}


\newpage
\nocite{*}	
\bibliography{bibliographie}
\bibliographystyle{gerplain} 


\appendix


\include{appendix}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\end{document}


.