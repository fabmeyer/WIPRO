\documentclass[a4paper,10.2pt,pdftex]{scrartcl}%NEU
\usepackage[T1]{fontenc}
\usepackage[utf8x]{inputenc} 
\usepackage[english, ngerman]{babel}
\usepackage[babel,german=swiss]{csquotes}
\usepackage{listings}
\usepackage{ltxtable} 
\usepackage{tabularx}
\usepackage{tabu}
\usepackage[final]{pdfpages}
\usepackage{graphicx}
\usepackage{url}
\usepackage{longtable}
\usepackage{wrapfig,lipsum,booktabs}
\usepackage{scrpage2} 
\usepackage{listings}
\pagestyle{scrheadings}
\automark{section}
%\usepackage{natbib}
%\usepackage[notocbib]{apacite}
\usepackage[top=3cm,bottom=3.5cm,left=3.5cm,right=3.5cm]{geometry} 

\usepackage{lmodern}

\DeclareOldFontCommand{\sc}{\normalfont\scshape}{\@nomath\sc}
\lstdefinelanguage{JavaScript}{
  keywords={typeof, new, true, false, catch, function, return, null, catch, switch, var, if, in, while, do, else, case, break},
  keywordstyle=\color{blue}\bfseries,
  ndkeywords={class, export, boolean, throw, implements, import, this},
  ndkeywordstyle=\color{darkgray}\bfseries,
  identifierstyle=\color{black},
  sensitive=false,
  comment=[l]{//},
  morecomment=[s]{/*}{*/},
  commentstyle=\color{purple}\ttfamily,
  stringstyle=\color{red}\ttfamily,
  morestring=[b]',
  morestring=[b]"
}

\lstset{
  basicstyle=\ttfamily,
}

%\usepackage{mathptmx}% Times (gut)
%\usepackage{beraserif}% Bera (wohl eher ungeeignet)
%\usepackage{mathpazo}% Palatino (gut!)
%\usepackage{bookman}% Bookman (etwas altert¸mlich)
%\usepackage{charter}% Charter (gut!) NEU
\usepackage{newcent}% Newcentury (gut)
%\usepackage{utopia}% Utopia (gut bis gut!)
%%%%% Ende Einfuegung

\usepackage[scaled]{helvet}%NEU
%\renewcommand{\sfdefault}{\rmdefault}%NEU

\usepackage[german]{varioref}

\usepackage{setspace}
\onehalfspacing
%\linespread{1.07}

\usepackage{ellipsis}

% .....

\usepackage[multiple]{footmisc}
%\usepackage[multiple,perpage]{footmisc}

\usepackage[alwaysadjust]{paralist}
\setlength{\pltopsep}{1ex}

%\deffootnote[1em]{1em}{1em}{\textsuperscript{\thefootnotemark\ }}

\usepackage[pdftex,
colorlinks=false, pdfborder={0 0 0},
bookmarksopen=true,
hyperfootnotes=false,
]{hyperref}
 

% Sicheres "Vgl.:" um Tippfehler zu vermeiden
\newcommand{\f}{\footnote}
\newcommand*{\VGL}{Vgl.:}
%\renewcommand{\opcittext}{a.~a.~O} 
%\renewcommand{\idemtext}{Ebenda} 
\newcommand{\first}[1]{\emph{#1}}
\newcommand{\q}[1]{\iflanguage{ngerman}{\flqq#1\frqq}{``#1''}}
\newcommand{\qq}[1]{\iflanguage{ngerman}{\frqq#1\flqq}{``#1''}}
\newcommand{\qs}[1]{\iflanguage{ngerman}{\flq#1\frq}{``#1''}}
\newcommand{\z}{\cite}
\newcommand{\e}{\emph}
%\newcommand{\c}{ \z}

% Korrekturanmerkungen am Rand (fett-kursiv)
\newcommand{\notiz}[1]{\marginline{\textbf{\textit{\footnotesize #1}}}}


%\hyphenation{Ge-schmacks-po-ren Ge-schmacks-po-re aus-schliess-lich Atmo-sph‰-re}

% BIBLATEX ?
%Infos

%\usepackage{biblatex}
%\include{natbib
\usepackage{bibgerm}
%\usepackage{opcit}
%\usepackage[notocbib]{apacite}
%\renewcommand{\opcittext}{a.a.O.}
%\renewcommand{\idemtext}{Ebenda}
\hyphenation{Wahr-nehm-ungs-}
\usepackage{xcolor}
%\pagecolor[HTML]{dedede}
\begin{document}

\begin{titlepage} 
 \begin{center} 
    \thispagestyle{empty}
  {\small  Hochschule Luzern \hfill Institut für Informatik   \\[.75ex]
\hrule 
\vspace{0.75ex}
WIPRO  \hfill Herbstsemester 2019\\  

%\hfill FS 2010
% \hfill Proseminar
}

%{\small }

\vspace{14ex}



{\LARGE Wirtschaftsprojekt}


\vspace{2ex}

%Anzahl Zeichen
{\large \today}\\
\vspace{2ex}
%2\,500 Wörter

%\vspace{2ex}cv2.calcHist


\vspace{9ex}


{\huge\bfseries\textsf{Simulation und Visualisierung von \\[-1mm] Quantenkryptografie \\[5.5mm] }}

%\subtitle{}


\vspace{5ex}

%\vfill
Betreuungspersonen \\[2mm] Dr.\,Esther Hänggi \\ Dr.\,Halldór Janetzko\\[3mm]


\vspace{8ex}

{\Large Adrian Althaus \\[2mm] Fabian Meyer  \Large {}}

\vspace{8ex}

% {\large 17. M‰rz 2007}

 %\vspace{4ex}
 
%\vfill

\end{center}
\end{titlepage}

\vspace*{1ex}
\thispagestyle{plain}
\hspace*{-4.2cm}
\includegraphics[]{deckblatt.pdf} 
\newpage
\abstract{
\subsection*{Abstract}
Das Ziel dieser Arbeit besteht in der Simulation und Visualisierung des BB84-Protokolls. Dazu wurden zwei Applikationen entwickelt, zum einen ein Java-Backend, welches sich um die Simulation kümmert, und ein Frontend zur Visualisierung im Browser. Der Fokus des Backends liegt auf der korrekten Berechnung der Simulation und der sauberen Implementation mithilfe von komponentenbasierter Entwicklung. Der Schwerpunkt des Frontends liegt auf der Erklärungsfähigkeit, Interaktivität, Didaktik und Ästhetik. Die beiden Applikationen wurden auf dem enterpriselab (link) der Hochschule Luzern deployt. Mit dem deployten Prototypen (Stand: 17.12). wurden Benutzertests durchgeführt, um ein Feedback zur Qualität der Applikation, insbesondere der Erklärungsfähigkeit, der Interaktion und der Visualisation einzuholen). Die Benutzertests fielen durchaus positiv aus, was als Projekterfolg gedeutet werden kann.} 
\newpage
\pdfbookmark{Inhalt}{toc}
\tableofcontents 
\newpage

\section{Problem, Fragestellung, Vision}
\subsection{Quantenkryptografie: Das BB84-Protokoll} 
In der Quantenverschlüsselung werden sich Eigenschaften der Quantenphysik zunutze gemacht, um damit Informationen verschlüsseln zu können. Gleichzeitig ist es eine inhärente Eigenschaft eines quantenphysikalischen Systems, dass bei einem Messvorgang das System selbst gestört wird. Diese Eigenschaft wird genutzt, um ein mögliches Abhören einer Botschaft detektieren zu können.

Eine Möglichkeit, Informationen mithilfe eines quantenphysikalischen Systems zu übertragen, ist die Polarisierung von Photonen. Dabei werden Photonen mithilfe geeigneter Gerätschaft polarisiert und dann durch einen Lichtwellenleiter verschickt. Am anderen Ende kann der Empfänger die Polarisation durch den Einsatz von optischen Geräten rekonstruieren und so die originale Botschaft wiederherstellen. 

Photonen können in 4 möglichen Zuständen polarisiert werden: 0°, 45°, 90° und 135°. Dabei stellen 0° und 90° gerade Polarisierungen dar und 45° und 135° diagonale Polarisierungen. Ein Bit kann nun in 2 möglichen Polarisierungen kodiert werden: 0 mit 0° oder 45° und 1 mit 90° oder 135°. Nur durch das Wissen der Polarisierung und der richtigen Basis kann das korrekte Bit bestimmt werden.

Ist das Protokoll erfolgreich durchgeführt worden unter Einhaltung von gewöhnlichen Sicherheitsvorkehrungen, können der Sender und der Empfänger erfolgreich einen Schlüssel generieren, mit dem sich Informationen ähnlich einem one-time pad (symmetrisch) verschlüsseln können. 

Ein weiterer, wichtiger Vorteil von Quantenverschlüsselung im Gegensatz zu konventioneller (asymmetrischer) Verschlüsselung ist, dass die Etablierung des Schlüssels auf physikalischen Eigenschaften beruht und nicht auf mathematischen Berechnungen wie beispielsweise Hashfunktionen. Diese physikalischen Eigenschaften lassen sich auch mit erhöhtem Rechenaufwand nicht umgeghen. Ebenso arbietet man in der Quantenverschlüsselung weitgehend mit probabilistischen Verfahren. Aufgrund von quantenphysikalischen Eigenschaften ist ein Abfangen von Photonen zwar grundsätzlich feststellbar, aber letzten Endes bleibt für Sender und Empfänger lässt sich die Frage, ob Photonen abgehört wurden, nur mit einer bestimmten Wahrscheinlichkeit beantworten. 


\subsubsection{BB84 Protokoll}
Das BB84-Protokoll, benannt nach seinen Erfindern, Charles Bennet und Gilles Brassard, und seinem Veröffentlichungsjahr 1984, ist das bekannteste Protokoll zur Realisierung einer Quantenverschlüsselung. Es soll hier kurz beschrieben werden.

Der Einfachheit halber gehen wir von 3 Personen aus: Alice, welche die Nachricht verschickt, Bob, welche sie empfängt und Eve, welche die Nachricht abhören möchte.

Ablauf:
\begin{enumerate}
\item Alice erzeugt einen zufälligen, genügend langen Bitstring
\item  Diesen Bitstring enkodiert Alice, indem sie für jedes Bit eine zufällige Basis wählt (gerade oder diagonal) und damit jedes Photon polarisiert
\item  Die polarisierten Photonen schickt Alice mithilfe eines optischen Mediums (in der Regel ein Glasfaserkanal) an Bob
\item  Wenn Bob die Photonen erhält, misst er die Polarisierung jedes einzelnen Photons mithilfe seiner zufällig gewählten Basis (gerade oder diagonal) und dekodiert so den Bitstring
\item  Durchschnittlich sollte Bob zu 50\% die richtige Basis wählen und daher das korrekte Bit (0 oder 1) zu 50\% rekonstruieren können
\item  Bob befragt nun Alice (über einen authentisierten, öffentlichen Kanal) über die Basis jedes einzelnen Photons
\item Jedes Bit, welches durch eine falsch gewählte Basis bestimmt wurde, wird gekürzt. Das heisst der Schlüssel wird durchschnittlich 50\% kürzer
\item  Zum jetzigen Zeitpunkt sollten Alice und Bob denselben, identischen Bitstring besitzen, dieser wird auch \q{sifted key} genannt
\item  Alice und Bob können über einen authentisierten, öffentlichen Kanal ein Teil des Bitstrings miteinander vergleichen, um sicherzugehen, dass sie nicht abgehört wurden
\item  Dieser Teil wird dann verworfen. Der restliche Teil bildet den \q{shared secret key}
\item  Falls Eve die Nachricht abhören will, muss sie die Polarisierung der Photonen zwischen Alice und Bob messen. Auch Eve muss daher eine zufällig generierte Abfolge von Basen (gerade und diagonal) verwenden, um die Polarisation zu messen
\item  Wenn Eve eine falsche Basis gewählt hat, wird die Polarisierung des jeweiligen Photons aufgrund zufälligerweise neu gesetzt
\item  Falls Eve alle Bits gemessen hat, sinkt die Wahrscheinlichkeit, dass Eve unentdeckt bleibt nach $n$ verglichenen Bits auf $(\frac{3}{4})^n$. Mithilfe von statistischen Tests kann überprüft werden, ob ein Mithörer die Photonen abgehört hat oder nicht
\item  Falls ein Mithörer vorhanden war, wird das Protokoll wiederholt
\item  Durch ein Absprechen können Alice und Bob eine andere Basenverteilung von geraden und diagonalen Basen als 50/50 benutzen. Dies führt zu längeren Schlüsseln bzw. weniger Kürzung
\end{enumerate}

\subsubsection{Kompromiss aus Simulation und Visualisierung des BB84-Protokolls}
Die Fragestellung, wie man ein solch komplexen Sachverhalt simulieren und gleichzeitig visualisieren könnte, war die Ausgangsstellung dieses Projektes. Von Anfang an gab es einen grossen Spielraum und Freiheit bei der Konzeption und Umsetzung. Da die beiden Autoren dieses Projektes beide einen anderen Background haben (Frontend bzw. Backend), kristallisierte sich langsam ein Konzept heraus, welches eine relativ klare Aufgabenteilung beinhaltete.

Für die Simulation bietet sich natürlich ein Backend an, bei welcher Performance und Robustheit oberste Priorität hat. Auf der anderen Seite kann die Visualisierung nur in einem Frontend sinnvoll verwirklicht werden, da hier mithilfe des Einsatz von Text, Bild und weiteren Medien die Thematik dem Benutzer erklärt werden kann.

Dies führte zu der Idee, eine Webapplikation zu programmieren, welche beide Anwendungen miteinander verbindet. Diese Verbindung führte zu einem bedingten Kompromiss: Das Backend generiert Daten für eine Simulation von quantenkryptografischer Verschlüsselung, bei welcher üblicherweise sehr grosse Datenmengen verarbeitet werden. Das Frontend hingegen muss den Sachverhalt möglichst einfach erklären können. Dazu sind keine grossen Datenmengen nötig. Die Daten werden für die Visualisierung über eine REST-Schnittstelle geladen. 

Dieser Kompromiss sollte erreicht werden, indem dem Benutzer trotzdem das Gefühl gegeben wird, dass hier sehr grosse Mengen von Daten verarbeitet werden und der Benutzer einen Einblick in die Komplexität der Thematik erhält. 
 



\subsection{Schwerpunkte}
Durch die Unterteilung in Frontend und Backend und deren Zuweisung an eine Person ergeben sich in beiden Bereichen unterschiedliche Schwerpunkte. Beim Frontend geht es im Wesentlichen um die Darstellung der Simulation der einzelnen Schritte des BB84-Protokolls, um diesen Prozess für den Benutzer möglichst lehrreich, intuitiv und ästhetisch befriedigend visualisieren zu können. Dies beinhaltet die die Repräsentation der einzelnen Komponenten der Simulation von Quantenkryptografie als UI-Elementen. Das Frontend soll vom User interaktiv bedienbar sein, um so die Erzeugung der Schlüssel der Quantenkryptografie auf geeignete Weise beeinflussen zu können.

Das Backend übernimmt die Abbildung der physikalischen Vorgänge der Quantenkryptografie als einzelne Komponenten, die über Schnittstellen miteinander verbunden sind.  und welche zu einem späteren Zeitpunkt mühelos erweitert, ausgetauscht und angepasst werden können. Die Simulation soll schlussendlich über eine API von aussen benutzbar, konfigurierbar und abgreifbar sein mit einem Bytestream als Output.

Unabhängig von der Umsetzung und Arbeitsteilung bildet ein Schwerpunkt die Erlangung der nötigen Kenntnisse, die für ein vertieftes Verständnis des BB84-Protokolls erforderlich sind.

\section{Stand der Praxis}
\subsection{Frontend / Informationsvisualiserung}
In den letzten Jahren haben sich die Möglichkeiten in der Datenvisualisierung rasant verändert. Gleichzeitig findet eine Verschiebung von statischer Berichterstattung mit Text und Bild zu dynamischen, interaktiven Multimediaformen statt.

Beispielsweise hat die Onlineausgabe der \emph{New York Times} seit dem Jahr 2014 eine neue Sparte namens \q{The Upshot}\footnote{\url{https://www.nytimes.com/section/upshot}}, auf welcher Artikel veröffentlicht werden, die politische, wirtschaftliche oder gesellschaftliche Themen durch den Einsatz von Techniken der Datascience und Datenvisualierung ergänzen, sogenanntes \q{data-driven storytelling} aufwerten. Diese Artikel sind dynamisch und interaktiv; der Benutzer kann die Daten manipulieren und so direkt in die Visualierung eingreifen.

Möglich macht dies Fortschritte nicht nur die Produktion leistungsfähigerer Computerhardware, sondern auch die Entwicklung von immer leistungsfähigerer Browsersoftware. Dabei findet eine stetige Verschiebung von Rendering auf der Serverseite zum Rendering auf der Clientseite statt. Wo früher grosse Mengen von Daten nur auf hochspezialiserten Computer berechnet und visualisiert werden konnten, kann dies heutzutage auch auf einem PC im Browser realisiert werden. Daher erstaunt es nicht, dass auch spezialisierte Datenvisualierungsbibliotheken, wie D3 für die clientseitige Scriptsprache JavaScript zur Verfügung stehen.

\subsection{Explorable Explainables}
Im letzten Jahrzehnt sind einige Tools, Frameworks, Markupsprachen oder Bibliotheken erschienen, welche sich darauf spezialisieren, Techniken der Datenvisualisierung zu benutzen, um so dynamischen, interaktiven und multimedialem content zu erzeugen. Diese unterscheiden sich jedoch gross in Bezug auf die Voraussetzungen des angesprochenen Benutzers (Informatik-Hintergrund oder Autor bei einer Zeitung) oder Domäne (spezialiserte Software oder allgemein einsatzfähig).

Diese Art von Software, welche Berichterstattung mit interaktiven Techniken der Datenvisualierung kombiniert wird als \emph{Explorable Explainables} bezeichnet. Die Abgrenzung zu anderer Software ist nicht ganz eindeutig, beispielsweise kann auch Project Jupyter verwendet werden, um Daten interaktiv zu visualisieren und dies einer grossen Audienz zugänglich zu machen. Jedoch verlangen Jupyter notebooks sehr viel Vorkentnisse in der Informatik und sind daher auf eine bestimmte Zielgruppe beschränkt. 
\subsection{Idyll}
Eine dieser Markupsprachen ist Idyll \footnote{\url{https://idyll-lang.org}}, welche die Erzeugung interaktiver Dokumente mit der Markupsprache Markdown verbindet. Idyll stellt eine Reihe von UI-Komponenten zur Verfügung, mit welchen sich einerseits Inhalte wie Text, Bild und Visualisierungen darstellen lassen, als auch Komponenten wie Regler, Eingabefelder und weitere, um Daten zu manipulieren.

Idyll selbst basiert auf der UI-Bibliothek React \footnote{\url{https://reactjs.org}}, welche anfänglich von Facebook entwickelt wurde und im Jahr 2013 als open-source Projekt der Öffentlichkeit zugänglich gemacht wurde. Die Philosophie von React beruht einerseits auf der Entwicklung von Komponenten mit Schnittstellen, die wiederverwendet werden können und andererseits auf der reaktiven Programmierung, ein relatives neues Programmierparadigma, welches Zustände und Änderungen einzig und allein auf Datenflüsse zurückführt. React eignet sich insbesonders um single-page Applications (SPAs) zu erzeugen. Dabei wird bei einem Seitenaufruf nur eine leere Hülle aus HTML geladen und der gesamte content wird beim client im Browser dynamisch durch JavaScript erzeugt (server-side Rendering, SSR).

Idyll verknüpft die einfache Herstellung von Komponenten von React mit dem simplen Markupsyntax von Markdown, mit welchem sich rasch einfache Dokumente schreiben lässt. Ähnlich wie bei LaTeX, wird bei Markdown Inhalt und Struktur gegenüber Layout getrennt. Das Layout kann einfach mit einer CSS-Datei gesteuert werden.

In Idyll wird also der einfache Syntax zum Schreiben von Texten mit Markdown mit dem System zur Erzeugung von Komponenten von React verknüpft. Bei der Kompilation werden gewöhnliche JavaScript-, HTML- und CSS-Dateien erzeugt, welche statisch auf einem Server abgelegt werden können.
\subsection{Vergleichbare Projekte}
Es existieren wenige Projekte, welche sich zum Ziel gemacht haben, das BB84-Protokoll oder Quantenverschlüsselung allgemein zu simulieren und visualisieren. 

Eines davon ist von Fred Henle aus dem Jahr 2008\footnote{\url{http://fredhenle.net/bb84/demo.php}}, welches das BB84-Protokoll auf eine spielerische Weise erklärt. Wie man rasch erkennt, ist es schon ein bisschen in die Jahre gekommen und entspricht nicht mehr dem Verständnis und Aussehen moderner Webseiten. Trotzdem ist es auf der englischsprachigen Wikipediaseite \footnote{\url{https://en.wikipedia.org/wiki/Quantum_key_distribution}} zu \emph{Quantum key distribution} aufgelistet.

Ein nennenswertes Beispiel ist auch der \emph{Quantum Computing Playground} \footnote{\url{http://www.quantumplayground.net/\#/home}}, mit welchem sich die Programmierung von Qubits mithilfe von Quantengates simulieren lässt. Obwohl sehr leistungsfähig (die Grafiken werden mit WebGL gerendert) und wissenschaftlich exakt, ist es nicht der Anspruch dieser Seite, eine solch komplexe Thematik auf einfache und verständliche Art und Weise erklären zu wollen.

Eine erschöpfende Liste von Software, welche sich primär mit Quantumcomputing befasst oder diese simuliert findet man auf Quantiki\footnote{\url{https://www.quantiki.org/wiki/list-qc-simulators}}, dem bekanntesten Informationsportal zu allen Themen der Quanteninformationstheorie und deren Anwendungen.
% Backend: Event getrieben vs Simulation getrieben. 

\subsection{Modularisierung}
% Backend: Event getrieben vs Simulation getrieben. 
Modularisierung ist ein grundlegendes Prinzip der Softwaretechnik. Sie hilft bei der Komplexitätsreduktion und erhöht die Flexibilität von Software. Unterteil man Software in verschiedene Module, so geschieht dies nach gängigen Kriterien wie minimale Schnittstellen, maximale Bindung, minimale Koppelung oder Testbarkeit. In Falle einer Simulation mit physikalischen Komponenten liegt es nahe, die einzelen Komponenten als in sich geschlossenes Modul zu betrachten. In Java geschieht dies auf technischer Ebene mit Interfaces. Damit eine Klasse zum Modul wird, muss sie richtig konzipiert sein. Unterstützend wirken Pakete und JARs, die aber keine Zugriffskontrolle über eine Schnittstelle kennen. Vor Java 9 war eine echte Modularisierung nur mit \emph{Open Services Gateway} (OSGi) möglich, welche aber nicht Teil des Standardumfangs von Java ist \cite[S. 32f]{modul}
\subsubsection{Modularisierung mit Java 9} 
Mit dem lange erwarteten Projekt \emph{Jigsaw} es eine explizite Erstellung von Modulen möglich. Sie können aus einem oder mehreren Paketen bestehen, und die Sichtbarkeiten und Abhängigkeiten sind klar definiert. So lassen sich gleichsam verschachtelte Modulabhängigkeiten und transitive Abhängigkeiten verwirklichen. Ein Modul besteht aus einem Namen, einer Schnittstelle und natürlich der Implementierung. Im Zuge von Jigsaw wurde auch das JDK in eine Vielzahl von Modulen aufgeteilt\cite[S. 863]{inden}. 

\begin{table}
\hspace{1cm}
\begin{tabular}{ll}
\texttt{exports} & Öffentlich zugänglich gemachte Pakete \\
\texttt{requires} & Liste importierbarer Module \\
\texttt{uses / provides} & Benötigter und angebotener \emph{service} \\
\texttt{opens} & Zugriff über Reflection erlauben
\end{tabular} 
\caption{Jigsaw Keywords}
\end{table}

Skalierbarkeit der Jva-Plattform, Erhöhung der Sicherhiet, Startup-Performance, Unterstüztung beim entwur fmodularer und gut wartbarer Anwendungen und Bibliotheken. 



\section{Ideen und Konzepte}
Aus der Aufgabenstellung geht hervor, dass sich das Projekt zum einen gewissen didaktischen Anforderunge erfüllen muss, zum anderen die Einbettung in bestehende Systeme am Departement für Informatik zu berücksichtigen hat. Insofern wurden Ansätze einer monolithischen Applikation bereits bei den ersten Überlegungen verworfen. Vielmehr hatte sich rasch herauskristallisiert, dass die unterschiedlichen Anwendungsfälle am besten mit einem modularen Kernsystem abgedeckt werden, die dann entweder in einem diaktischen Kontext als Webapplikation, oder dann eben im produktivem Einsatz beispielsweise als CLI-Tool eingebunden werden. Dadurch lässt sich das Projekt zudem in ein Frontend und Backend einteilen, für die dann -- abhängig von den jeweiligen Präferenzen --  je einer der beiden Projektpartner zugewiesen werden können. Zum Projektstart hat man sich auf eine Modellierung geeinigt, die das BB84-Protokoll physikalisch in einer Webapplikation abbildet, wobei es zu der jeweiligen physikalischen Komponente je eine Entsprechung im Frontend und Backend gibt, die miteinander interagieren. Der Ablauf der BB84-Protokoll wird somit in Teilschritte gegliedert, die unabhängig voneinander atomar ausgeführt werden können. Bei jedem dieser Teilschritte wird die REST-Schnittstelle mit den benötigten Parametern angesteuert. Das Backend arbeitet damit stateless. 

\subsection{Alternative Ideen}
Die offene Aufgabenstellung und die Zielsetzung lassen viele Freiheiten bei der Konzeption des Projekts zu.

Da die beiden Autoren jedoch unterschiedliche Ausrichtungen und Fähigkeiten besitzen (Frontend vs. Backend), hat sich ein Konzept angeboten, welche auf der Frontendseite die Visualierung und auf der Backendseite die Logik umsetzt. Für das Backend sollen Module entwickelt werden, die in unterschiedlichen Kontexten eingebunden werden können. Dies erschien als die sinnvollste Lösung für die beiden unterschiedlichen Anwendungszwecke.  Dieser Ansatz stand rasch fest. Die Kombination aus Idyll und Java-Backend musste sich erst herauskristallisieren. Für Java sprach die Unterstützung von Modularisierung ebenso wie der Aspekt der Performance. Darüber hinaus wird Java an der Hochschule Luzern unterrichtet. Idyll machte mit Blick auf die Idee eines interaktiven Papers einen überzeugenden Eindruck. Dennoch haben stand Python als Backendlösung zur Debatte. 

Hinsichtlich der Kommunikation zwischen Frontend und Backend war es lange nicht ganz eindeutig, inwiefern das Backend Kenntnisse über den Zustand des Frontends haben sollte. Versuchsweise wurde deshalb für die Zwischenspeicherung von berechnetetn Werten auf dem Server eine Unterstützung für Sessions eingebaut. Das Frontend beinhaltete in einer früheren Version einen Settings-Button, der Parameter, die bei mindestens zwei unterschiedlichen physikalischen Komponenten benötigt werden, an den Server für eine Ablage in der Session sendet. Im weiteren Projektverlauf wurde dieser Ansatz verworfen, weil sich die Anzahl Parameter wie auch die Datengrösse der Payloads im jeweiligen Requests in Grenzen hielt. Die Verbindung einer REST-Schnittstelle und Sessions erschien dann quasi als Antipattern, da REST einerseits für ein zustandsloses Paradigma steht. Und ein zustandsloses Backend macht grundsätlich Sinn, da sich atomare Ausführungseinheiten besser parallelisieren oder gar auslagern lassen, etwa in eine Cloud als Function-as-a-Service. Und wenn das Zusammenspiel mit dem Frontend zustandslos funktionert, wird es dies bei der Einbindung der Komponenten in anderen Kontexten sowieso tun. 

\section{Methoden}
\subsection{Vorgehensmodell}
Aufgrund der Aufgabenstellung empfiehlt sich ein hybrides Vorgehensmodell nach SODA. Ein Wasserfallmodell ist aus dem einfachen Grund ausgeschlossen, dass zum Zeitpunkt des Projektstarts der genaue Projektumfang noch nicht vorlag. Das Minimalziel liegt in der Umsetzung der Minimalanforderung, i.e. ein Schulbeispiel des BB84-Prototkolls. Die weiteren Punkte während der Projektverlaufs fortwährend festgelegt. Die Abstände zwischen den Treffen mit den Auftraggeber erlaubt ein agiles Vorgehen. Der primäre Milestone bestand in der Abnahme des Testates in der Semesterwoche 10, wo es die Erreichung der minimalen Ziele unter Beweis zu stellen galt.

\subsection{Frontend: Benutzertests}
Um das Frontend evaluieren zu können, wurde ein high-fidelity Prototyp (Stand: 17.12.2019) auf dem Enterpriselab deployt. Dann wurden Informationen an Bekannte ausgegeben mit der Bitte, den Prototypen zu testen und das Formular mit den Fragen (auf Google forms) auszufüllen. Es wurden bewusst Personen aus verschiedenen Altersklassen und Berufen ausgewählt, da es ja gerade das Ziel des Frontends ist, den Sachverhalt zu erklären.

Es wurden Remote Usertests durchgeführt, das heisst alle Benutzer konnten den Prototypen von zuhause aus in Ruhe anschauen und testen. Es wurden zuerst allgemeine Fragen zu Geschlecht und Alter und je eine Frage zum Wissenstand in Physik respektive Informatik gestellt, die Fragen zum Wissenstand wurden quantitativ beantwortet, mit Werten von 1 bis 6. Dies diente als warm-up für die Benutzer und um nötige demografische Informationen und Informationen zum Wissenshintergrund der Testpersonen zu erlangen.

Dann wurden je 4 Fragen zu den Bereichen Erklärung (Erklärungsfähigkeit), Interaktion und Visualisierung gestellt. Bei jedem Bereich wurde zuerst eine allgemeine Frage zum Eindruck davon quantitativ gestellt (1 bis 6), dann je eine qualitative Frage, was man besonders gut fand, je eine qualitative Frage, was man besonders schlecht fand und wieder eine quantitative Frage (1 bis 6) zu einem bestimmten Komponenten. Damit erfolgt wieder zuerst ein warm-up mit einer einfacheren, allgemeinen Frage.

Zum Schluss konnten die Benutzer frei ihre Gedanken als Anmerkungen, Kritik, Wünsche und offene Fragen. Damit konnte man alle Informationen einholen, die vorher in den Fragen nicht gestellt worden waren.

Die Evaluierung der Benutzerumfrage fliess so gut es ging noch in die Weiterentwicklung der Applikation (insbesondere des Frontends) mit ein. Die Erkentnisse der Resultate sind im Kapitel 7 festgehalten und der Fragebogen mit Antworten im Anhang.

\subsection{Testing Backend}
Im Backend sind im test-package Unit-Tests enthalten, welche die korrekte Berechnung der entsprechenden Aufrufe sicherstellen sollen. 


\section{Realisierung}
Die Aufgabenstellung verlangt eine Art Zweiteilung der Programmierarbeiten. Die Umsetzung der physikalischen Komponenten ist zunächst einmal unabhängig vom Einsatzzweck. Bei den beiden Anwendungsfällen aber werden sie auf unterschiedliche Weisen angesprochen. Bei der Vermittlung des BB84-Protokolls an interessierten Personen kommt ein interaktives Webfrontend zum Zuge, das über eine REST-Schnittstelle mit dem Java-Backend kommuniziert. Die eigentlichen Komponenten können als Java-Kompontenten angesprochen werden. 


\subsection{Frontend}
Das Frontend wurde mithilfe von Idyll und React umgesetzt. Die Grundstruktur eines idyll-Projektes besteht aus einem index.idyll file und einem Ordner mit allen Komponenten. Das index.idyll file ist vergleichbar mit einem HTML-file, welches für die Struktur des Dokumentes zuständig ist. In dieses file wird dann der gesamte Text und alle Komponenten eingebunden.
\subsubsection{Verwendete Idyll-Komponenten}
Idyll bringt eine Reihe von Komponenten mit, die jedoch alle ziemlich simpel sind und von welchen nicht gross Gebrauch gemacht wurde. Einzige Ausnahmen sind:

\begin{tabularx}{\textwidth}{p{2.5cm}p{8.5cm}}
Header & Der header der Webseite, mit allen wichtigen Informationen.\\
var & Eine Input-Komponente, mit der man eine Variable definieren kann. \\
fullWidth & Eine Komponente, welche als Wrapper benutzt wird, um den inneren Komponenten auf die ganze Seitenbreite zu rendern. \\
Equation & Eine Komponente, welche es ermöglicht LaTeX-Syntax direkt im index.idyll-file zu schreiben. \\
Display & Eine Komponente, welche den Wert einer Variable anzeigt, mit zusätzlichen Möglichkeiten der Formatierung.
\end{tabularx}

\subsubsection{Verwendete npm packages}
\begin{tabularx}{\textwidth}{p{3cm}p{8.5cm}}
react-arrow &  Ein package, welches einen Komponenten ausgibt, der einen Pfeil als canvas-Element rendert. \\
react-anime &  Ein package, welches einen Wrapper um die JavaScript-Bibliothek animejs bildet. Damit lassen sich Animationen generieren, indem man für verschiedene Keyframes Werte eines bestimmten properties eingibt. \\
react-emoji-render &  Ein package, mit welchem sich einfach ein emoji darstellen läst. \\
react-rough &  Ein package, welches einen Wrapper um die JavaScript-Bibliothek roughjs bildet, mit der man Grafiken als canvas oder svg rendern kann, die einen handgemalten Stil besitzen. Sämtliche Grafiken in der Applikation wurden mit diesem package erstellt. \\
react-slider&  Ein package, mit welchem sich einfach ein Regler rendern lässt und bei dem man alle grafischen  Details per css genau steuern kann. Dieses package wurde verwendet um alle Regler im Dokument zu erstellen. \\
rodal&  Ein package, welches ein Modal (ein kleines Fenster, welches alles andere im Hintergrund verblasst)  rendert.

\end{tabularx}

\subsubsection{Arten von Komponenten}
\begin{tabularx}{\textwidth}{p{3cm}p{8.5cm}} 
Visuelle Komponenten &  Sind Komponenten, die Sachverhalte visuell darstellen, um sie so dem Benutzer veranschaulicht erklären zu können. \\
Logik-Komponenten & Sind Komponenten, die für die Logik des Frontends gebraucht werden, um den Ablauf des Algorithmus darstellen zu können. Sie sind entweder mit dem backend via der REST-API verbunden oder benutzen eine interne Logik, welche nur für das frontend von Bedeutung ist. \\
Input-Komponenten & Sind Komponenten, die der Benutzer bedienen kann, um den Programmablauf zu steuern.
\end{tabularx}
\subsubsection{Erstellte Komponenten} 
\begin{description}
\item[SystemOverview] Eine visuelle Komponente, die dazu dient dem Benutzer schon früh im Dokument eine Übersicht über das BB84-Protokoll zu geben und ihm die Möglichkeit zu geben, wichtige Einstellungen der Simulation festlegen zu können. Sie zeigt die drei Teilnehmer des Algorithmus, Alice, Bob und Eve, sowie die zwei Übertragungskanälen samt den einstellbaren Parameter.
\begin{figure}[h]
	\centering
  \includegraphics[width=\textwidth]{graphics/component_system_overview.png}
	\caption{System overview}
\end{figure}
\item[ButtonAliceStart] Eine Logik-Komponente, welche einen Button rendert, der den Algorithmus startet. Dabei wird die \texttt{strLength} zusammen mit \texttt{AliceProb} per POST-Methode an das Backend geschickt, um damit Alices Bitstring und ihre Base zu berechnen. Als Antwort kommt dann der Bitstring und die Base zurück.
\item[PhotonGridDouble] Eine visuelle Komponente, welche zwei Strings entgegennimmt und diese rendert als zwei Raster von einzelnen Symbolen. Der Hintergrund des Rasters kann bei Bedarf gefärbt werden (was am Schluss auch gemacht wird). Diese Komponente wird benutzt um zwei Strings (Bitstring oder Base) darzustellen. Per Klick auf das Raster öffnet sich ein Modal, welches den String in einem quadratischen Fenster darstellt (Komponente ScrollBox). 
\begin{figure}[h]
	\centering
  \includegraphics[width=0.5\textwidth]{graphics/component_photon_grid_double.png}
	\caption{Photon grid double}
\end{figure} 
\item[scrollBox] Eine visuelle Komponente, welche einen String in einem quadratischen Fenster darstellt. Es besitzt einen Slider, mit dem man die Schriftgrösse des Keys anpassen kann. Wird die Schriftgrösse zu klein, wechselt die Darstellung des Schlüssels von Text zu einem Bitmuster. Es existiert eine kleine Legende, welche die Farben des Bitmusters erklärt.
\begin{figure}[h]
	\centering
  \includegraphics[width=0.5\textwidth]{graphics/component_scroll_box.png}
	\caption{Scroll Box}
\end{figure}
\item[InformationBox] Eine visuelle Komponente, welche eine Tabelle rendert, die den für das Verständnis wichtigen Zusammenhang zwischen Bitstring, Base und resultierende Polarisation veranschaulicht.
\begin{figure}[h]
	\centering
  \includegraphics[width=0.5\textwidth]{graphics/component_information_box.png}
	\caption{Information Box}
\end{figure}
\item[SimpleSlider] Eine kleine Input-Komponente, welche nur einen Regler rendert, der genau ein property beeinflusst. 
\begin{figure}[h]
	\centering
  \includegraphics[width=0.4\textwidth]{graphics/component_simple_slider.png}
	\caption{Simple slider}
\end{figure}
\item[ButtonEmitPhotons] Eine Logik-Komponente, welche einen Button rendert, der den Algorithmus weiterführt. Damit wird aus dem Bitstring und der Base von Alice ein String von Polarisationen berechnet. Der Bitstring und die Base werden wieder per POST-methode an das backend geschickt und als Antwort kommt ein String von Polarisationen für Bob zurück.
\begin{figure}[h]
	\centering
  \includegraphics[width=0.4\textwidth]{graphics/component_button_emit_photons.png}
	\caption{ButtonEmitPhotons}
\end{figure}
\item[ShowHide] Eine kleine Logik-Komponente, welche als Wrapper dazu dient eine innere Komponente mithilfe einer Bedingung ein- oder ausblenden zu können. So können zum Beispiel Visualisierungen oder Animationen nach Bedarf eingeblendet werden.
\item[AnimationEmit] Eine visuelle Komponente, welche darstellt, dass Photonen von Alice zu Bob geschickt werden
\begin{figure}[h]
	\centering
  \includegraphics[width=\textwidth]{graphics/component_animation_emit.png}
	\caption{AnimationEmit}
\end{figure}
\item[ButtonBobBase] Eine Logik-Komponente, welche durch die Stringlänge und die Wahrscheinlichkeit der Basenverteilung von Bob eine Base für Bob berechnet. Die Stringlänge und die Wahrscheinlichkeitsverteilung werden per POST-methode an das backend geschickt, welches als Antwort eine Base für Bob zurückschickt. 
\begin{figure}[h]
	\centering
  \includegraphics[width=0.8\textwidth]{graphics/component_button_bob_base.png}
	\caption{ButtonBobBase}
\end{figure}
\end{description}
\subsection{Physikalische Komponenten}
Im Backend sind die physikalischen Komponenten verwirklicht, welche je durch eine eigene Klasse repräsentiert werden. Die Anzahl Komponenten wie auch deren Attribute sind gegeben durch die erreichten Funktionalitäten in der Umsetzung des BB84-Protokolls. Den Komponenten entspricht in der Regel eine Komponente im Frontend, jedoch kann ein Schritt in der Durchführung mehrere Komponente involvieren. Folgende Komponenten sind umgesetzt.
\begin{description} 
\item[RandomBitString] Generiert einen Bitstring der Länge n \\
\begin{tabular}{p{3cm}p{9cm}}
stringLength & Länge des Bitstrings \\
prob & Wahrscheinlichkeit von 0 oder 1 \\
\end{tabular}
\item[RandomBase]  Generiert eine zufällige Basis \\
\begin{tabular}{p{3cm}p{7.5cm}}
n & Länge der Base \\    
prob & Wahrscheinlichkeit von Rückgabewert orthogonal im Verhältnis zu diagonal
\end{tabular} 
\item[PhotonEmitter] Schickt eine Reihe von Photonen  \\
\begin{tabular}{p{3cm}p{9cm}}
base & Base \\
str & bitString \\  
\end{tabular}
\item[PhotonReceiver]
Diese Komponente repräsentiert Bob, der einen Photonenstring empfängt.  \\
\begin{tabular}{p{3cm}p{7.5cm}}
photons & Photon String   \\
base  & String mit Basen  \\
noise &  Noise String, 0 - 100  \% \\ 
eavesdropping  & Anteil an Eavesdropping 
\end{tabular} 
\item[Channel] 
Diese Komponente repräsentiert den Übertragungskanal. \\
\begin{tabular}{p{3cm}p{7.5cm}}
Noise  & Polarisierung verändert sich, 0 - 100\% \\
Eavesdropping & Polarisierung verändert sich, 0 - 100\% \\
\end{tabular} 
\item[BaseComparator] Diese Komponente vergleicht zwei Basenstrings miteinander \\  \begin{tabular}{p{3cm}p{9cm}}
Base1 & Base String 1   \\
Base2 & Base String 2  
\end{tabular}
\item[KeyShortener] 
Diese Komponente vergleicht die Basen von Alice und Bob und simuliert damit den öffentlichen Kanal. Anhand der Bitstrings von Alice und Bob werden damit zwei unterschiedliche Bitstrings zurückgegeben, die jeweils einen Underscore an allen Stellen enthalten, wo sich die entsprechenden Stellen in den beiden Basen unterscheiden. 
\\
\begin{tabular}{p{3cm}p{7.5cm}}
base1  & Basis von Alice \\
base2  & Basis von Bob \\
string\_alice &  Bitstring von Alice \\
string\_bob & Bitstring von Bob \\ 
state\_string & Spezieller Statusstring vom Frontend, der die Information über Noise und Eavesdropping an den jeweiligen Stellen enthält und bei jeder Abweichung der Basen gekürzt werden muss \\
\end{tabular} 
\item[KeyComparator] 
Diese Komponente überprüft die Bitstrings von Alice und Bob und überprüft anhand eines prozentualen Werts, wie hoch der Anteil sein soll, der überprüft und danach verworfen werden soll. \\
\begin{tabular}{p{3cm}p{7.5cm}}
restStringAlice  & Polarisierung verändert sich, 0 - 100\% \\
restStringBob & Polarisierung verändert sich, 0 - 100\% \\
colorString & String, der spezifisch für das Frontend mitvearbeitet wird und die Statusinformationen zu den Photonen enthält, der mit der Kürzung ebenfalls gestutzt werden muss. 
\end{tabular} 
\end{description}


\subsection{Backend}
Im Backend residiert ein Tomcat-Server. Bei der lokalen Entwicklung wird er als EmbeddedTomcat bereitsgestellt. Das Gradle-Skript enthält zudem alle Maven-Dependencies, die für den Server von Interesse sind oder bei dereinstigen Weiterentwicklungen gebraucht werden könnten, etwas im Bereich von Persistierung, Dependency-Injection oder Session-Handling. Das Backend wird mit \texttt{.gradlew clean run} gestartet, sodass das Backend unter Port 8080 erreichbar ist. Mit Blick auf Security ist es lediglich für den Port 3000 geöffnet, was dem Idyll-Server während des Entwicklungsprozesses entspricht. 

Die eingehenden Requests der REST-Schnittstelle werden von einem REST-Adapter abgefangen und an den \emph{service} weitergeleitet. Der Service holt im Anschluss die Argumente der Abfrage und ruft die entsprechenden Komponenten auf. Der Server liefert schlussendlich ein JSON-Objekt an den Client zurück, der die entsprechenden Information als Key konsultiert (\"bitstring\", \"commonKey", \dots). 


\subsection{Installation und Deployment}
Der Code besteht aus einem \texttt{backend\_jaxrs}-Verzeichnis und einem \texttt{wipro\_v1}-Ordner, welcher das Idyll-Projekt beinhaltet. Mit \texttt{idyll build} lässt sich im Frontend-Verzeichnis das Projekt nach einer Ändeurng neu bilden. Das Resultat landet im \texttt{build}-Verzeichnis und muss im Anschluss beim Backend in \texttt{src/main/webapp} kopiert werden, was die Startseite des Tomcat-Servers überschreibt. Mit \texttt{./gradlew build} wird der Build-Prozess gestartet, was bei einer Java-Webapplikation stets ein .war-File produziert. Das damit generierte ROOT.war kann in jeden beliebigen Tomcat-Server deployt werden. 

Die ganze Applikation ist auch als Docker-Image verfügbar. Die Installation setzt also einen Docker-Client und eine Unix / Linux-Maschine voraus. Danach kann das Skript \texttt{install-docker.sh}-File ausgeführt werden.  Ausserdem ist sie noch bis zum 31.01.2020 in einer virtuellen Umgebung auf dem Enterpriselab erreichbar \footnote{\url{http://wiproh19-tbalthau.enterpriselab.ch:8080/}}

\section{Evaluation, Testing und Validation}
\subsection{Benutzertests und Umfrage}
Für die Evaluation des Frontends wurden Benutzertests mit dem Prototyp (Stand: 17.12.2019) durchgeführt und die User füllten anschliessend ein Umfragebogen von Google forms aus. Insgesamt bearbeiteten 13 Benutzer die Applikation und füllten den Umfragebogen aus, der Arbeitsaufwand für die Bearbeitung ist ca. 15 Minuten.

Die Benutzer gaben an von Physik 4,1 von 6 Punkte zu verstehen und von Informatik 3,8 von 6 Punkten. Dies lässt auf Benutzer schliessen, die eher wenig Erfahrung mit Physik und Informatik haben und deswegen eher keinen technischen Hintergund haben.
\subsection{Erkenntnisse zur Erklärungsfähigkeit der Webseite}
Insgesamt konnte das BB84-Protokoll gut erklärt werden, mit einem Mittelwert von 4,8 von 6 Punkten.

Als besonders gut wurden genannt, wie in diesem Protokoll auf den secret key geschlossen werden kann (drei Personen), die Erklärung wie das BB84-Protokoll grundsätzlich funktioniert (drei Personen) und die grafische Darstellung der polarisierten Photonen (drei Personen). Der Ablauf der Applikation scheint logisch zu sein und die Visualisierungen helfen den Benutzer den Sachverhalt zu verstehen.

Als nicht gut erklärt, wurde von drei Personen genannt, wie das Abhören die Polarisierung verändert und dass das noise bzw. die Ablenkung im Kanal nicht weiter erklärt wird (zwei Personen). Weiterhin wurde gefragt, Warum das Protokoll schlussendlich sicher sein und dass die beiden Basen besser erklärt werden müssen. Unterdessen wurde bereits ein Kapitel zum Thema noise eingefügt. Bei einer weiteren Iteration sollte also mehr Zeit in die Erklärung der Basen und deren Messvorgang investiert werden um die Polarisierung von Photonen bei der Messung besser erklären zu können.

Die Frage, ob die Systemübersicht für die Erklärung geholfen hat, wurde sehr positiv beantwortet, mit einem Mittelwert von 4,7 von 6 Punkten. Bei einer weiteren Iteration sollte besonders Wert darauf gelegt werden, die Systemübersicht auszubauen und um mehr Graphiken und Einstellungsmöglichkeiten erweitern. 
\subsection{Erkentnisse zur Interaktion}
Die Qualität der Interaktion der Webseite wurde durchschnittlich mit 4,7 von 6 Punkten bewertet.

Am meisten gelobt wurden die Regler, um Werte einzustellen (zwei Personen). Weiterhin wurde genannt, dass die Interaktivität einem dazu einlädt in den Prozess einzugreifen (eine Person), dass es gut sei, das noise zu setzen, da ansonsten meistens von einem perfekten System ausgegangen wird (eine Person) und dass es gut sei, das Abhören zu setzen, um später den Einfluss daraus auf die Schlüssel zu sehen (eine Person). Wenn die Applikation vervollständigt werden würde, sollten wieder die selben UI-Elemente eingesetzt werden, da diese von den Benutzern als positiv bewertet wurden.

Negativ bewertet wurde, dass bestimmte Elemente erst erscheinen, wenn auf Buttons geklickt wird (eine Person) und dass gewisse Einstellungen der Systemübersicht später wieder erneut gesetzt werden können (eine Person). Auch wurde erwähnt, dass die Buttons irgendwie behandelt werden sollen, damit sie nicht schon vor dem jeweiligen Zeitpunkt im Ablauf des Algorithmus geklickt werden können. Dies wurde unterdessen bereits im frontend umgesetzt. Die Animationen mit den Photonen, die von links nach rechts fahren und dann wieder zurückspringen wurde von einer Person als störend wahrgenommen. Bei mehr Zeitaufwand könnten die Animationen überarbeitet werden.

Die Idee, einen Komponenten zu entwickeln, mit dem man in einen String reinzoomen kann umzusetzen wurde sehr positiv aufgenommen (4,8 Punkte von 6). Von diesem Komponente könnte mehr und besseren Gebrauch gemacht werden, wenn beispielsweise realistischere features, wie bursts eingebaut wären. Damit liessen sich solche zeitabhängige Einflüsse auf die Schlüsselerzeugung gut visualisieren.
\subsection{Erkentnisse zur Visualisierung}
Die Visualisierung wurde mit 4,6 Punkte von 6 schlechter als die Erklärungsfähigkeit und die Interaktion bewertet.

Mit Abstand am meisten gelobt wurde erneut die Systemübersicht (fünf Personen), es wurde genannt, dass sie die Darstellung ist, welche das Protokoll am besten zusammenfassen kann und sehr eindeutig ist. Weitere 5 Personen nannten die Darstellung der Polarisierung der Photonen, bzw. die Änderung der Polarisation beim Messen als sehr gut. Hier ist unklar, welche Visualisierung genau gemeint ist, da mehrere Komponenten die Polarisierung darstellen (unter anderem auch die `informationBox`). Gelobt wurde die visuelle Umsetzung und die Ästhetik von zwei Personen.

Als negative Kommentare wurden beispielsweise genannt, dass bei der Messung des Photons mit einem Filter, welches eine andere Ausrichtung besitzt die Polarisierung des Photons zufällig gesetzt werden müsste (wie im Text erklärt) und nicht immer gleich (eine Person). Dies könnte mit Programmieraufwand so umgesetzt werden.

Die Frage, wie gut die Animation mit den Photonen und dem Filter dazu beigetragen haben den Sachverhalt mit der Polarisierung zu verstehen wurde mit 4,5 von 6 eher schlecht bewertet. Wir denken, dass diese Animationen wichtig sind für das Verstehen des Protokolls. Bei mehr verfügbarer Zeit müssten sie angepasst werden, damit die neue Polarisierung zufällig gewählt wird anstatt immer dieselbe.

\subsection{Konklusion}
Grundsätzlich wurde der Prototyp sehr positiv bewertet. Es war schwierig Personen zu finden, welche Interesse hatten den Prototypen zu testen und anschliessend das Formular auszufüllen. Teilweise wurden Dinge bemängelt, welche nicht direkt mit dem BB84-Protokoll zusammenhangen, bzw. den Rahmen der Thematik und der Applikation gesprengt hätten, wie die Erklärung, wie die beiden Basen zustande kommen oder warum nun das BB84-Protokoll sicher sei.

Die wichtigsten Punkte aus der Benutzerumfrage sind zusammengefasst:


Der Algorithmus kann als ganzes durchaus gut erklärt werden. Dies ist sehr erfreulich, da es sich hiermit um ein komplexes Thema handelt, mit dem sich die meisten Personen der Umfrage wahrscheinlich noch nie befasst haben.
\begin{itemize}
\item Die Sytstemübersicht wurde sehr positiv aufgenommen und hat auch uns persönlich gefallen. Die Idee einen visuellen Überblick über das System schon ganz am Anfang des Dokuments zu geben ist sehr gut und könnte auch für weitere Projekte in der Art benutzt werden.
\item Die Animationen und Visualisierungen sind grundsätzlich gut und überzeugen auch ästhetisch. Bei einer weiteren Iteration oder einem anderen Projekt könnten die verwendeten Bibliotheken erneut verwendet werden.
\item Das Ziel des frontends, das BB84-Protokoll auf eine interaktive und ansprechende Weise zu erklären konnte also erreicht werden. 
\end{itemize}


\section{Ausblick}
\subsection{ Realistischere Simulation des BB84-Protokolls}

Um das BB84-Protokoll realistischer darstellen zu können, müsste man auf jeden Fall die Möglichkeit zur Verfügung stellen, dass der Photonenemitter Photonen zu viel oder zu wenig aussendet und dass der Photonendetektor Photonen zu viel oder zu wenig detektiert. Dies führt jedoch automatisch zu einer Veränderung der Länge und einer Verschiebung der jeweiligen Strings von Polarisationen (und Bits) von Alice und Bob. Damit dieses feature realisiert werden kann, muss jedoch gezwungenermassen ein timestamp mitgeschickt werden, mit dem jedes Photon datiert wird. Nur so können Alice und Bob Gewissheit haben, ob das jeweilige Photon ausgesendet und auch angekommen ist.

Weiterhin müssten Prozesse wie Rauschen (noise) oder Abhören (eavesdropping) als zeitabhängige, anstatt rein stochastische Prozesse implementiert werden. Das heisst, dass Rauschen und Abhören nicht mit einer konstanten Rate auftritt, sondern mit zeitabhängigen Variabeln modelliert werden sollte. Beispielsweise tritt Rauschen dann plötzlich auf (sogenannte "bursts") und flacht dann wieder ab. Und Eve wird möglicherweise nur ein Teil der Übertragung (dafür alle Photonen davon) messen, anstatt ein Verhältnis der gesamten Übertragung.

\subsection{Modularisierung}
Im Verlaufe des Projektes hat sich der Fokus fast ausschliesslich auf den Lehrzweck verschoben, sodass die Modularisierung für eine Anbindugn an weitere Projekte an Bedeutung verloren hat. Insofern hat es keinen Sinn ergeben, Jigsaw als Neuerung von Java 9 zu nutzen. Der Modularisierungsgrad könnte aber ausgebaut werden. 


\subsection{Frontend}
Bei mehr verfügbarer Zeit wären im frontend die folgenden Verbesserungen implementiert worden:
\begin{itemize}
\item Die Systemübersicht wäre um die realistischeren features, wie oben beschrieben ergänzt worden. Diese könnten mithilfe von Regler am jeweiligen Ort einfach dargestellt werden.
\item Eine verkleinerte Darstellung der Systemübersicht (eine Art minimap) sollte dem User jederzeit eingeblendet werden, um den Standpunkt im Ablauf des Algorithmus zu visualisieren. Diese wäre beispielsweise in der oberen rechten Ecke platziert und würde nicht im Dokument mitscrollen. Darauf könnten dann die jeweiligen Komponenten, welche gerade im Algorithmus eine Rolle spielen farblich hervorgehoben werden.
\item Ein Plot am Ende des Dokumentes, vor der Konklusion könnte verwendet werden, um die Länge des common shared keys vs. der Länge des anfänglichen Bitstrings von Alice zu plotten. Damit könnte man visualisieren, wie sich die Wahl der Basen, das Rauschen und das Abhören auf die Länge des resultierenden Strings auswirken. Die Realisierung könnte mit einer Bibliothek, wie D3.js erfolgen.
\item Im Verlauf des Dokuments sollte dem User mehr feedback gegeben werden, damit die App sich interaktiver präsentiert und sich der Ablauf des Algorithmus weniger atomar anfühlt.
\end{itemize}


\newpage
\nocite{*}	
\bibliography{bibliographie}
\bibliographystyle{gerplain} 


\appendix


\include{appendix}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\end{document}


.