\documentclass[a4paper,10.2pt,pdftex]{scrartcl}%NEU
\usepackage[T1]{fontenc}
\usepackage[utf8x]{inputenc} 
\usepackage[english, ngerman]{babel}
\usepackage[babel,german=swiss]{csquotes}
\usepackage{listings}
\usepackage{ltxtable} 
\usepackage{tabularx}
\usepackage{tabu}
\usepackage{graphicx}
\usepackage{url}
\usepackage{wrapfig,lipsum,booktabs}
\usepackage{scrpage2} 
\usepackage{listings}
\pagestyle{scrheadings}
\automark{section}
%\usepackage{natbib}
%\usepackage[notocbib]{apacite}
\usepackage[top=3cm,bottom=3.5cm,left=3.5cm,right=3.5cm]{geometry} 

\usepackage{lmodern}

\DeclareOldFontCommand{\sc}{\normalfont\scshape}{\@nomath\sc}
\lstdefinelanguage{JavaScript}{
  keywords={typeof, new, true, false, catch, function, return, null, catch, switch, var, if, in, while, do, else, case, break},
  keywordstyle=\color{blue}\bfseries,
  ndkeywords={class, export, boolean, throw, implements, import, this},
  ndkeywordstyle=\color{darkgray}\bfseries,
  identifierstyle=\color{black},
  sensitive=false,
  comment=[l]{//},
  morecomment=[s]{/*}{*/},
  commentstyle=\color{purple}\ttfamily,
  stringstyle=\color{red}\ttfamily,
  morestring=[b]',
  morestring=[b]"
}

\lstset{
  basicstyle=\ttfamily,
}

%\usepackage{mathptmx}% Times (gut)
%\usepackage{beraserif}% Bera (wohl eher ungeeignet)
%\usepackage{mathpazo}% Palatino (gut!)
%\usepackage{bookman}% Bookman (etwas altert¸mlich)
%\usepackage{charter}% Charter (gut!) NEU
\usepackage{newcent}% Newcentury (gut)
%\usepackage{utopia}% Utopia (gut bis gut!)
%%%%% Ende Einfuegung

\usepackage[scaled]{helvet}%NEU
%\renewcommand{\sfdefault}{\rmdefault}%NEU

\usepackage[german]{varioref}

\usepackage{setspace}
\onehalfspacing
%\linespread{1.07}

\usepackage{ellipsis}

% .....

\usepackage[multiple]{footmisc}
%\usepackage[multiple,perpage]{footmisc}

\usepackage[alwaysadjust]{paralist}
\setlength{\pltopsep}{1ex}

%\deffootnote[1em]{1em}{1em}{\textsuperscript{\thefootnotemark\ }}

\usepackage[pdftex,
colorlinks=false, pdfborder={0 0 0},
bookmarksopen=true,
hyperfootnotes=false,
]{hyperref}
 

% Sicheres "Vgl.:" um Tippfehler zu vermeiden
\newcommand{\f}{\footnote}
\newcommand*{\VGL}{Vgl.:}
%\renewcommand{\opcittext}{a.~a.~O} 
%\renewcommand{\idemtext}{Ebenda} 
\newcommand{\first}[1]{\emph{#1}}
\newcommand{\q}[1]{\iflanguage{ngerman}{\flqq#1\frqq}{``#1''}}
\newcommand{\qq}[1]{\iflanguage{ngerman}{\frqq#1\flqq}{``#1''}}
\newcommand{\qs}[1]{\iflanguage{ngerman}{\flq#1\frq}{``#1''}}
\newcommand{\z}{\cite}
\newcommand{\e}{\emph}
%\newcommand{\c}{ \z}

% Korrekturanmerkungen am Rand (fett-kursiv)
\newcommand{\notiz}[1]{\marginline{\textbf{\textit{\footnotesize #1}}}}


%\hyphenation{Ge-schmacks-po-ren Ge-schmacks-po-re aus-schliess-lich Atmo-sph‰-re}

% BIBLATEX ?
%Infos

%\usepackage{biblatex}
%\include{natbib
\usepackage{bibgerm}
%\usepackage{opcit}
%\usepackage[notocbib]{apacite}
%\renewcommand{\opcittext}{a.a.O.}
%\renewcommand{\idemtext}{Ebenda}
\hyphenation{Wahr-nehm-ungs-}
\usepackage{xcolor}
%\pagecolor[HTML]{dedede}
\begin{document}

\begin{titlepage} 
 \begin{center} 
    \thispagestyle{empty}
  {\small  Hochschule Luzern \hfill Institut für Informatik   \\[.75ex]
\hrule 
\vspace{0.75ex}
WIPRO  \hfill Herbstsemester 2019\\  

%\hfill FS 2010
% \hfill Proseminar
}

%{\small }

\vspace{14ex}



{\LARGE Wirtschaftsprojekt}


\vspace{2ex}

%Anzahl Zeichen
{\large \today}\\
\vspace{2ex}
%2\,500 Wörter

%\vspace{2ex}cv2.calcHist


\vspace{9ex}


{\huge\bfseries\textsf{Simulation und Visualisierung von \\[-1mm] Quantenkryptografie \\[5.5mm] }}

%\subtitle{}


\vspace{5ex}

%\vfill
Betreuungspersonen \\[2mm] Dr.\,Esther Hänggi \\ Dr.\,Janetzko Halldór\\[3mm]


\vspace{8ex}

{\Large Adrian Althaus \\[2mm] Fabian Meyer  \Large {}}

\vspace{8ex}

% {\large 17. M‰rz 2007}

 %\vspace{4ex}
 
%\vfill

\end{center}
\end{titlepage}

\vspace*{1ex}
\thispagestyle{plain}
\pdfbookmark{Inhalt}{toc}
\tableofcontents
\newpage
\section{Problem, Fragestellung, Vision}
\subsection{Quantenkryptografie: Das BB84-Protokoll} 
In der Quantenverschlüsselung werden sich Eigenschaften der Quantenphysik zu eigen gemacht, um damit Informationen verschlüsseln zu können. Gleichzeitig ist es eine inhärente Eigenschaft eines quantenphysikalischen Systems, dass bei einem Messvorgang das System selbst gestört wird. Diese Eigenschaft wird benutzt, um ein mögliches Abhören einer Botschaft detektieren zu können.

Eine Möglichkeit, Informationen mithilfe eines quantenphysikalischen Systems zu übertragen, ist die Polarisierung von Photonen. Dabei werden Photonen mithilfe von geeigneter Gerätschaft polarisiert und dann durch einen Lichtwellenleiter verschickt. Am anderen Ende kann der Empfänger die Polarisation durch den Einsatz von optischen Geräten rekonstruieren und so die originale Botschaft wiederherstellen.

Photonen können in 4 möglichen Zuständen polarisiert werden: 0°, 45°, 90° und 135°. Dabei stellen 0° und 90° gerade Polarisierungen dar und 45° und 135° diagonale Polarisierungen.

Ein Bit kann nun in 2 möglichen Polarisierungen kodiert werden: 0 mit 0° oder 45° und 1 mit 90° oder 135°. Nur durch das Wissen der Polarisierung und der richtigen Basis kann das korrekte Bit bestimmt werden.

Ist das Protokoll erfolgreich durchgeführt worden unter Einhaltung von gewöhnlichen Sicherheitsvorkehrungen, können der Sender und der Empfänger erfolgreich einen Schlüssel generieren, mit dem sie Informationen ähnlich einem one-time pad (symmetrisch) verschlüsseln können.

Ein weiterer, wichtiger Vorteil von Quantenverschlüsselung im Gegensatz zu konventioneller (asymmetrischer) Verschlüsselung ist, dass die Etablierung des Schlüssels auf physikalischen Eigenschaften beruht und nicht auf mathematischen Berechnungen, wie beispielsweise von Hashfunktionen. Diese physikalischen Eigenschaften lassen sich auch mit erhöhtem Rechenaufwand nicht umgeghen.


\subsubsection{BB84 Protokoll}
Das BB84-Protokoll, benannt nach seinen Erfindern, Charles Bennet und Gilles Brassard, und seinem Veröffentlichungsjahr 1984, ist das bekannteste Protokoll zur Realisierung einer Quantenverschlüsselung. Es soll hier kurz beschrieben werden.

Der Einfachheit halber gehen wir von 3 Personen aus: Alice, welche die Nachricht verschickt, Bob, welche sie empfängt und Eve, welche die Nachricht abhören möchte.

Ablauf:
\begin{enumerate}
\item Alice erzeugt einen zufälligen, genügend langen Bitstring
\item  Diesen Bitstring enkodiert Alice, indem sie für jedes Bit eine zufällige Basis wählt (gerade oder diagonal) und damit jedes Photon polarisiert
\item  Die polarisierten Photonen schickt Alice mithilfe eines optischen Mediums (in der Regel ein Glasfaserkanal) an Bob
\item  Wenn Bob die Photonen erhält, misst er die Polarisierung jedes einzelnen Photons mithilfe seiner zufällig gewählten Basis (gerade oder diagonal) und dekodiert so den Bitstring
\item  Durchschnittlich sollte Bob zu 50% die richtige Basis wählen und daher das korrekte Bit (0 oder 1) zu 50% rekonstruieren können
\item  Bob befragt nun Alice (über einen authentisierten, öffentlichen Kanal) über die Basis jedes einzelnen Photons
\item Jedes Bit, welches durch eine falsch gewählte Basis bestimmt wurde, wird gekürzt. Das heisst der Schlüssel wird durchschnittlich 50% kürzer
\item  Zum jetzigen Zeitpunkt sollten Alice und Bob denselben, identischen Bitstring besitzen, dieser wird auch *sifted key* genannt
\item  Alice und Bob können über einen authentisierten, öffentlichen Kanal ein Teil des Bitstrings miteinander vergleichen, um sicherzugehen, dass sie nicht abgehört wurden
\item  Dieser Teil wird dann verworfen. Der restliche Teil bildet den *shared secret key*
\item  Falls Eve die Nachricht abhören will, muss sie die Polarisierung der Photonen zwischen Alice und Bob messen. Auch Eve muss daher eine zufällig generierte Abfolge von Basen (gerade und diagonal) verwenden, um die Polarisation zu messen
\item  Wenn Eve eine falsche Basis gewählt hat, wird die Polarisierung des jeweiligen Photons aufgrund zufälligerweise neu gesetzt
\item  Falls Eve alle Bits gemessen hat, sinkt die Wahrscheinlichkeit, dass Eve unentdeckt bleibt nach $n$ verglichenen Bits auf $(\frac{3}{4})^n$. Mithilfe von statistischen Tests kann überprüft werden, ob ein Mithörer die Photonen abgehört hat oder nicht
\item  Falls ein Mithörer vorhanden war, wird das Protokoll wiederholt
\item  Durch ein Absprechen können Alice und Bob eine andere Basenverteilung von geraden und diagonalen Basen als 50/50 benutzen. Dies führt zu längeren Schlüsseln bzw. weniger Kürzen
\end{enumerate}

\subsubsection{Kompromiss aus Simulation und Visualisierung des BB84-Protokolls}
Die Fragestellung, wie man ein solch komplexen Sachverhalt simulieren und gleichzeitig visualisieren könnte war die Ausgangsstellung dieses Projektes. Von Anfang an gab es einen grossen Spielraum und Freiheit bei der Konzeption und Umsetzung.

Da die zwei Autoren dieses Projektes beide einen anderen Background haben (frontend, bzw. backend), kristallisierte sich langsam ein Konzept heraus, welches eine relativ klare Aufgabenteilung beinhaltete.

Für die Simulation bietet sich natürlich ein Backend an, bei welcher Performance und Robustheit oberste Priorität hat. Auf der anderen Seite kann die Visualisierung nur in einem Frontend sinnvoll verwirklicht werden, da hier mithilfe des Einsatz von Text, Bild und weiteren Medien die Thematik dem Benutzer erklärt werden kann.

Dies gab uns die Idee, eine Webapplikation zu programmieren, welche beide Anwendungen miteinander verbindet. Diese Verbindung führte zu einem bedingten Kompromiss: Das Backend generiert Daten für eine Simulation von quantenkryptografischer Verschlüsselung, bei welcher üblicherweise sehr grosse Datenmengen verarbeitet werden. Das Frontend hingegen muss den Sachverhalt möglichst einfach erklären können. Dazu sind keine grossen Datenmengen nötig.

Wir denken, dass uns dieser Kompromiss gelungen ist, indem dem Benutzer trotzdem das Gefühl gegeben wird, dass hier sehr grosse Mengen von Daten verarbeitet werden und der Benutzer einen Einblick in die Komplexität der Thematik erhält.
 
 



\section{Stand der Praxis Adrian}
\section{Ideen und Konzepte}
Aus der Aufgabenstellung geht hervor, dass sich das Projekt zum einen gewissen didaktischen Anforderunge erfüllen muss, zum anderen die Einbettung in bestehende Systeme am Departement für Informatik zu berücksichtigen hat. Insofern wurden Ansätze einer monolithischen Applikation bereits bei den ersten Überlegungen verworfen. Vielmehr hatte sich rasch herauskristallisiert, dass die unterschiedlichen Anwendungsfälle am besten mit einem modularen Kernsystem abgedeckt werden, die dann entweder in einem diaktischen Kontext als Webapplikation, oder dann eben im produktivem Einsatz als CLI-Tool eingebunden werden. Dadurch lässt sich das Projekt zudem in ein Frontend und Backend einteilen, für die dann -- abhängig von den jeweiligen Präferenzen --  je einer der beiden Projektpartner zugewiesen werden können. Zum Projektstart hat man sich auf eine Modellierung geeinigt, die das BB84-Protokoll physikalisch in einer Webapplikation abbildet, wobei es zu der jeweiligen physikalischen Komponente je eine Entsprechung im Frontend und Backend gibt, die miteinander interagieren. 

\subsection{Schwerpunkte}
Durch die Unterteilung in Frontend und Backend und deren Zuweisung an eine Person ergeben sich in beiden Bereichen unterschiedliche Schwerpunkte. Beim Frontend geht es im Wesentlichen um die Darstellung der Simulation der einzelnen Schritte des BB84-Protokolls, um diesen Prozess für den Benutzer möglichst lehrreich, intuitiv und ästhetisch visualisieren zu können. Dies beinhaltet die die Repräsentation der einzelnen Komponenten der Simulation von Quantenkryptografie als UI-Elementen. Das Frontend soll vom User interaktiv bedienbar sein, um so die Erzeugung der Schlüssel der Quantenkryptografie auf geeignete Weise beeinflussen zu können.

Das Backend übernimmt die Abbildung der physikalischen Vorgänge der Quantenkryptografie als einzelne Komponenten, die über Schnittstellen miteinander verbunden sind.  und welche zu einem späteren Zeitpunkt mühelos erweitert, ausgetauscht und angepasst werden können. Die Simulation soll schlussendlich über eine API von aussen benutzbar, konfigurierbar und abgreifbar sein (Bytestrom als Output).

\section{Stand der Praxis Fabian}
\subsection{Frontend / Informationsvisualiserung}
In den letzten Jahren haben sich die Möglichkeiten in der Datenvisualisierung rasant verändert. Gleichzeitig findet eine Verschiebung von statischer Berichterstattung mit Text und Bild zu dynamischen, interaktiven Multimediaformen statt.

Beispielsweise hat die Onlineausgabe der *New York Times* seit dem Jahr 2014 eine neue Sparte namens "The Upshot" (https://www.nytimes.com/section/upshot), auf welcher Artikel veröffentlicht werden, welche politische, wirtschaftliche oder gesellschaftliche Themen durch den Einsatz von Techniken der Datascience und Datenvisualierung ergänzen, sogenanntes "data-driven storytelling". Diese Artikel sind dynamisch und interaktiv; der Benutzer kann die Daten manipulieren und so direkt in die Visualierung eingreifen.

Möglich macht dies Fortschritte, nicht nur in der Produktion leistungsfähigerer Computerhardware, sondern auch in der Entwicklung von immer leistungsfähigerer Browsersoftware. Dabei findet eine stetige Verschiebung von Rendering auf der Serverseite zum Rendering auf der Clientseite statt. Wo früher grosse Mengen von Daten nur auf hochspezialiserten Computer berechnet und visualisiert werden konnten, kann dies heutzutage auch auf einem personal computer im Browser realisiert werden. Daher erstaunt es nicht, dass auch spezialisierte Datenvisualierungsbibliotheken, wie D3 für die clientseitige Scriptsprache JavaScript zur Verfügung stehen.

\subsection{Explorable Explainables}
Im letzten Jahrzehnt sind einige Tools, Frameworks, Markupsprachen oder Bibliotheken erschienen, welche sich darauf spezialisieren, Techniken der Datenvisualisierung zu benutzen, um so dynamischen, interaktiven und multimedialem content zu erzeugen. Diese unterscheiden sich jedoch gross in Bezug auf die Voraussetzungen des angesprochenen Benutzers (Informatik-Hintergrund oder Autor bei einer Zeitung) oder Domäne (spezialiserte Software oder allgemein einsatzfähig).

Diese Art von Software, welche Berichterstattung mit interaktiven Techniken der Datenvisualierung kombiniert wird als *Explorable Explainables* bezeichnet. Die Abgrenzung zu anderer Software ist nicht ganz eindeutig, beispielsweise kann auch Project Jupyter verwendet werden, um Daten interaktiv zu visualisieren und dies einer grossen Audienz zugänglich zu machen. Jedoch verlangen Jupyter notebooks sehr viel Vorkentnisse in der Informatik und sind daher auf eine bestimmte Zielgruppe beschränkt. 
\subsection{Idyll}
Eine dieser Markupsprachen ist Idyll (https://idyll-lang.org), welche die Erzeugung interaktiver Dokumente mit der Markupsprache Markdown verbindet. Idyll stellt eine Reihe von UI-Komponenten zur Verfügung, mit welchen sich einerseits content wie Text, Bild und Visualisierungen darstellen lässt, als auch Komponenten, wie Regler, Eingabefelder und mehr, um Daten zu manipulieren.

Idyll selbst basiert auf der UI-Bibliothek React (https://reactjs.org), welche anfänglich von Facebook entwickelt wurde und im Jahr 2013 als open-source Projekt der Öffentlichkeit zugänglich gemacht wurde. Die Philosophie von React beruht einerseits auf der Entwicklung von Komponenten mit Schnittstellen, die wiederverwendet werden können und andererseits auf der reaktiven Programmierung, ein relatives neues Programmierparadigma, welches Zustände und Änderungen einzig und allein auf Datenflüsse zurückführt. React eignet sich insbesonders um single-page Applications (SPAs) zu erzeugen. Dabei wird bei einem Seitenaufruf nur eine leere Hülle aus HTML geladen und der gesamte content wird beim client im Browser dynamisch durch JavaScript erzeugt (server-side Rendering, SSR).

Idyll verknüpft die einfache Herstellung von Komponenten von React mit dem simplen Markupsyntax von Markdown, mit welchem sich rasch einfache Dokumente schreiben lässt. Ähnlich wie bei LaTeX, wird bei Markdown Inhalt und Struktur gegenüber Layout getrennt. Das Layout kann einfach mit einer CSS-Datei gesteuert werden.

In Idyll wird also der einfache Syntax zum Schreiben von Texten mit Markdown mit dem System zur Erzeugung von Komponenten von React verknüpft. Bei der Kompilation werden gewöhnliche JavaScript-, HTML- und CSS-Dateien erzeugt, welche statisch auf einem Server abgelegt werden können.
\subsection{Vergleichbare Projekte}
Es existieren wenige Projekte, welche sich zum Ziel gemacht haben, das BB84-Protokoll oder Quantenverschlüsselung allgemein zu simulieren und visualisieren.

Eines davon ist von Fred Henle, aus dem Jahr 2008: \url{http://fredhenle.net/bb84/demo.php}, welches das BB84-Protokoll auf eine spielerische Weise erklärt. Wie man rasch erkennt, ist es schon ein bisschen in die Jahre gekommen und entspricht nicht mehr dem Verständnis und Aussehen moderner Webseiten. Trotzdem ist es auf der englischsprachigen Wikipediaseite zu "Quantum key distribution" aufgelistet (\url{https://en.wikipedia.org/wiki/Quantum_key_distribution}).

Ein nennenswertes Beispiel ist auch der "Quantum Computing Playground" (\url{http://www.quantumplayground.net/#/home}), mit welchem sich die Programmierung von Qubits mithilfe von Quantengates simulieren lässt. Obwohl sehr leistungsfähig (die Grafiken werden mit WebGL gerendert) und wissenschaftlich exakt, ist es nicht der Anspruch dieser Seite, eine solch komplexe Thematik einfach erklären zu wollen.

Eine erschöpfende Liste von Software, welche sich primär mit Quantumcomputing befasst oder diese simuliert findet man auf https://www.quantiki.org/wiki/list-qc-simulators. Quantiki ist das bekannteste Informationsportal zu allen Themen der Quanteninformationstheorie und deren Anwendungen.
% Backend: Event getrieben vs Simulation getrieben. 

\section{Ideen und Konzepte}
\subsection{Alternative Ideen}
Da die Aufgabenstellung und die Zielsetzung sehr offen sind, hatten wir grosse Freiheit bei der Konzeption des Projekts.

Da die beiden Autoren jedoch unterschiedliche Ausrichtungen und Fähigkeiten besitzen (frontend und backend), hat sich ein Konzept angeboten, welche auf der Frontendseite die Visualierung umsetzt und auf der Backendseite die Simulation umsetzt. Beide Autoren haben sich jedoch tiefgründig mit der Theorie zum BB84-Protokoll auseinandergesetzt.

Die Schwerpunkte wurden auf folgende, messbare Eigenschaften gelegt:
\begin{itemize}
\item Das nötige Verständnis erlangen über die Quantenkryptografie (wissenschaftliche Korrektheit)
\item Saubere Implementation der Simulation (komponentenbasiertes Vorgehen im Backend, Wiederverwendbarkeit und Austauschbarkeit)
\item Visualisierung (ästhetische Anforderung und Interaktivität)
\item Präsentation (didaktische Anforderungen, Erklärungsfähigkeit und Usability-aspekte) 
\end{itemize}


\subsection{Physikalische Komponenten}

\subsubsection*{ Bitstring Generator}
\begin{itemize}
\item Länge
\item  Wahrscheinlichkeitsverteilung / Wahrscheinlichkeit von Rückgabewert 1 im Gegensatz zu Rückgabewert 0
\end{itemize}
\subsubsection*{ Basen Generator}
\begin{itemize}
\item  Länge       
\item  Wahrscheinlichkeitsverteilung / Wahrscheinlichkeit von Rückgabewert rectilinear im Gegensatz zu Rückgabewert diagonal
\end{itemize}

\subsubsection*{ Photon Emitter}
\begin{itemize}
\item Frequenz / Speed des Outputs
\item  Ungenauigkeit der erzeugten Polarisierung (Winkel verändert sich, 0 - 100\%) 
\item  Photon zuviel ausgesendet
\item  Photon zuwenig ausgesendet
\end{itemize}

\subsubsection*{ Photon Empfänger}
\begin{itemize}
\item  Frequenz / Speed des Inputs
\item  Ungenaugkeit der gemessenen Polarisierung (falscher Winkel gemessen, 0 - 100\%) 
\item  Prozentsatz falsche Messung (nichtexistentes Photon gemessen)
\item  Prozentsatz fehlgeschlagene Messung (Photon bleibt unbemerkt)
\end{itemize}
\subsubsection*{ Übertragungskanal}
\begin{itemize}
\item  Verlustrate (Photon geht verloren)
\item  Noise (Polarisierung verändert sich, 0 - 100%)
\end{itemize}

\subsubsection*{ Comparator}
\begin{itemize}
\item Basis / Bitstring 1
\item Basis / Bitstring 2
\end{itemize}
\subsubsection*{ Eavesdropping}
\begin{itemize}
\item  Basis
\end{itemize}

\section{Realisierung}
\subsection{Architektur}
Die Aufgabenstellung verlangt eine Art Zweiteilung der Programmierarbeiten. Die Umsetzung der physikalischen Komponenten ist zunächst einmal unabhängig vom Einsatzzweck. Bei den beiden Anwendungsfällen aber werden sie auf unterschiedliche Weisen angesprochen. Bei der Vermittlung des BB84-Protokolls an interessierten Personen kommt ein interaktives Webfrontend zum Zuge, das über eine REST-Schnittstelle mit dem Java-Backend kommuniziert. Die eigentlichen Komponenten können als Java-Kompontenten angesprochen werden. 
\subsubsection{Das modulare Prinzip}  
\subsubsection{Client-Server Architektur}



\subsection{Frontend}
Das frontend wurde mithilfe von idyll und react umgesetzt. Die Grundstruktur eines idyll-Projektes besteht aus einem index.idyll file und einem Ordner mit allen Komponenten. Das index.idyll file ist vergleichbar mit einem HTML-file, welches für die Struktur des Dokumentes zuständig ist. In dieses file wird dann der gesamte Text und alle Komponenten eingebunden.
\subsubsection{Verwendete Idyll-Komponenten}
Idyll bringt eine Reihe von Komponenten mit, die jedoch alle ziemlich simpel sind und von welchen nicht gross Gebrauch gemacht wurde. Einzige Ausnahmen sind:

\begin{tabularx}{\textwidth}{p{2.5cm}p{11cm}}
var & Eine Input-Komponente, mit der man eine Variable definieren kann. \\
fullWidth & Eine Komponente, welche als Wrapper benutzt wird, um den inneren Komponenten auf die ganze Seitenbreite zu rendern. \\
Equation & Eine Komponente, welche es ermöglicht LaTeX-Syntax direkt im index.idyll-file zu schreiben. \\
Display & Eine Komponente, welche den Wert einer Variable anzeigt, mit zusätzlichen Möglichkeiten der Formatierung.
\end{tabularx}

\subsubsection{Verwendete npm packages}
\begin{tabularx}{\textwidth}{p{3cm}p{11cm}}
react-arrow&  Ein package, welches einen Komponenten ausgibt, der einen Pfeil als canvas-Element rendert. \\
react-anime&  Ein package, welches einen Wrapper um die JavaScript-Bibliothek animejs bildet. Damit lassen sich Animationen generieren, indem man für verschiedene Keyframes Werte eines bestimmten properties eingibt. \\
react-emoji-render&  Ein package, mit welchem sich einfach ein emoji darstellen läst. \\
react-rough&  Ein package, welches einen Wrapper um die JavaScript-Bibliothek roughjs bildet, mit der man Grafiken als canvas oder svg rendern kann, die einen handgemalten Stil besitzen. Sämtliche Grafiken in der Applikation wurden mit diesem package erstellt. \\
react-slider&  Ein package, mit welchem sich einfach ein Regler rendern lässt und bei dem man alle grafischen  Details per css genau steuern kann. Dieses package wurde verwendet um alle Regler im Dokument zu erstellen. \\
rodal&  Ein package, welches ein Modal (ein kleines Fenster, welches alles andere im Hintergrund verblasst)  rendert.

\end{tabularx}

\subsubsection{Arten von Komponenten}
\begin{tabularx}{\textwidth}{p{3cm}p{11cm}} 
Visuelle Komponenten &  Sind Komponenten, die Sachverhalte visuell darstellen, um sie so dem Benutzer veranschaulicht erklären zu können. \\
Logik-Komponenten & Sind Komponenten, die für die Logik des frontends gebraucht werden, um den Ablauf des Algorithmus darstellen zu können. Sie sind entweder mit dem backend via der REST-API verbunden oder benutzen eine interne Logik, welche nur für das frontend von Bedeutung ist. \\
Input-Komponenten & Sind Komponenten, die der Benutzer bedienen kann, um den Programmablauf zu steuern.
\end{tabularx}
\subsection{Erstellte Komponenten}
\begin{itemize}
\item \texttt{SystemOverview} \\Eine visuelle Komponente, die dazu dient dem Benutzer schon früh im Dokument eine Übersicht über das BB84-Protokoll zu geben und ihm die Möglichkeit zu geben, wichtige Einstellungen der Simulation festlegen zu können. Die Systemübersicht verfügt über folgende Variabeln: \\[3mm]
\begin{tabularx}{\textwidth}{p{3cm}p{11cm}} 
strLength & Die Länge des Bitstrings, der von Alice verschickt wird. Diese Länge wird auch automatisch benutzt für die Länge der Basenfolge von Alice, sowie des Bitstrings und der Basenfolge von Bob und der Basenfolge von Eve. Die Stringlänge lässt sich mittels eines Eingabefensters mithilfe einer Tastatur eingeben. \\
noise & Diese Variable bezeichnet das Rauschen des Übertragungskanals. Bei einem Rauschen von 0 erfolgt eine perfekte Übertragung, bei 100 wird jede Polarisation zufälligerweise neu gesetzt. Das Rauschen lässt sich mit einem Regler einstellen. \\
AliceProb & Die Wahrscheinlichkeit der Basenverteilung von Alice. Von 0 (100\% diagonale Basis) bis 100 (100\% gerade Basis) lässt sich dies mithilfe eines Reglers steuern. \\
BobProb & Wie AliceProb, jedoch für Bob. \\
eavesdropping & Das Verhältnis, wie stark Eve die Übertragung abhört. Mit einem Regler lässt sich ein Wert von 0\% bis 100\% einstellen.
\end{tabularx}
\item \texttt{ButtonAliceStart}\\
Eine Logik-Komponente, welche einen Button rendert, welcher den Algorithmus startet. Dabei wird die `strLength` per POST-methode an das backend geschickt, zusammen mit `AliceProb`, um damit Alices Bitstring und ihre Base zu berechnen. Als Antwort kommt dann der Bitstring und die Base zurück. Dieser Button besitzt folgende Variabeln: \\[3mm]
\begin{tabularx}{\textwidth}{p{3cm}p{11cm}} 
strLength & Die Länge des Bitstrings, wie oben beschrieben. \\
AliceProb & Die Wahrscheinlichkeitsverteilung der Basen, wie oben beschrieben. \\
bitString & Der Bitstring, der als Antwort vom backend zurückkommt. \\
baseString &  Die Base, die als Antwort vom backend zurückkommt. \\
autostart & Ein boolean, mit welchem sich der Algorithmus automatisch ausführen lässt, wenn das Dokument fertig geladen ist. \\
dataHasLoaded & Ein boolean, welcher auf true geschaltet wird, wenn der Bitstring und die Base fertig geladen sind. \\
text &  Der Text, welcher auf dem Button erscheint. 
\end{tabularx}
\item \texttt{PhotonGridDouble}\\
 Eine visuelle Komponente, welcher einen String rendert als ein Raster von einzelnen Symbolen. Per Klick auf das Raster öffnet sich ein Modal, welches den String in einem quadratischen Fenster darstellt (Komponente `ScrollBox`). Diese Komponente wird benutzt um einen Bitstring und eine zugehörige Base darzustellen. Ihre Variabeln sind: \\[3mm]
\begin{tabularx}{\textwidth}{p{3cm}p{11cm}} 
bitString & Der obere String, der dargestellt werden soll. \\
baseString & Der untere String, der dargestellt werden soll. \\
dataHasLoaded & Ein boolean, welcher steuert, wann das Raster mit Zeichen gefüllt werden soll. \\
bitStringZoom & Eine variable, welche den Zoomfaktor des oberen Strings steuert. \\
baseStringZoom & Eine variable, welche den Zoomfaktor des unteren Strings steuert.
\end{tabularx}
\item \texttt{InformationBox} \\
Eine visuelle Komponente, welche eine Tabelle rendert, die den wichtigen Zusammenhang zwischen Bitstring, Base und resultierende Polarisation veranschaulicht.
\item \texttt{SimpleSlider} \\
 Eine kleine input-Komponente, welche nur einen Regler rendert, der genau ein property beeinflusst. Diese Komponente hat zwei Variabeln \\[3mm]
\begin{tabularx}{\textwidth}{p{3cm}p{11cm}} 
setting & Das property, das beeinflusst werden sollte. \\
text & Der Text, welcher neben dem Regler steht.
\end{tabularx}
\item \texttt{ButtonEmitPhotons} \\
Eine Logik-Komponente, welche einen Button rendert, welcher den Algorithmus weiterführt. Damit wird aus dem Bitstring und der Base von Alice einen String von Polarisationen berechnet. Der Bitstring und die Base werden wieder per POST-methode an das backend geschickt und als Antwort kommt ein String von Polarisationen zurück.
Die Variabeln dieses Komponentes sind:
\begin{tabularx}{\textwidth}{p{3cm}p{11cm}} 
bitString & Alices Bitstring, welcher für die Polarisation codiert. \\
baseString & Alices Basestring, welcher für die Polarisation codiert. \\
rawPolarization & Die Antwort vom backend, als ein String von Polarisationswerten (0, 45, 90 oder 135), getrennt durch ein Komma. \\
polarization & Alices Polarisation, als Array von getrennten Polarisationen \\
noise &  Das Rauschen, welches die Übertragung beeinflusst (siehe oben bei der Systemübersicht). \\
polarizationHasLoaded & Ein boolean, welcher auf true gesetzt wird, wenn die Polarisation geladen und in das Array geschrieben wurde. \\
text & Der Text, welcher auf dem Button erscheint.
\end{tabularx}
\item \texttt{ShowHide} \\
Eine kleine Logik-Komponente, welch als Wrapper dazu dient eine innere Komponente mithilfe einer Bedingung ein- oder ausblenden zu können. Ihre Variabeln sind: \\[3mm]
\begin{tabularx}{\textwidth}{p{3cm}p{11cm}} 
isVisible & Der boolean, welcher bestimmt, ob die innere Komponente ein- oder ausgeblendet ist. \\
showButton & Die Möglichkeit, einen Button zu rendern, der den boolean umschaltet \\
trigger & Ein anderer boolean, welcher das Verhalten dieses Komponenten extern ansteuern kann. \\
position & Ein CSS-Attribut, mit welchem man die Position des Wrappers festlegt
\end{tabularx}
\item \texttt{AnimationEmit} \\
Eine visuelle Komponente, welche zeigt, dass Photonen von Alice zu Bob geschickt werden
\item \texttt{ButtonBobBase} \\
Eine Logik-Komponente, welche durch die Stringlänge und die Wahrscheinlichkeit der Basenverteilung von Bob eine Base für Bob berechnet. Die Stringlänge und die Wahrscheinlichkeitsverteilung werden per POST-methode an das backend geschickt, welches als Antwort eine Base für Bob zurückschickt. Ihre Variabeln sind: \\[3mm]
\begin{tabularx}{\textwidth}{p{3cm}p{11cm}} 
strLength & Die Stringlänge, welche die Länge von Bobs Base festlegt. \\
BobProb & Die Wahrscheinlichkeitsverteilung, welche für die festlegung von Bobs Base wichtig ist. \\
baseString & Die Variable, welche die zurückgesendete Base speichert \\
bobBaseHasLoaded & Ein boolean, welcher auf true gesetzt wird, wenn die Base gespeichert ist. \\
text & Der Text, welcher auf dem Button erscheint.
\end{tabularx}
\item \texttt{AnimationPhoton1} \\
Eine visuelle Komponente, welche zeigt, wie ein Photon ein Filter durchdringt und nicht neu polarisiert wird, da es eine passende Polarisierung besitzt.
\item \texttt{AnimationPhoton2} \\
Eine visuelle Komponente, welche zeigt, wie ein Photon ein Filter durchdringt und neu polarisiert wird, da es eine falsche Polarisierung besitzt.
\item \texttt{ButtonMeasure} \\
Eine Logik-Komponente, mit welcher der Benutzer Bob die erhaltenen Photonen mit seiner Base messen lässt. Dabei werden Alices Photonen, Bobs Base und das Rauschen per POST-Methode an das Backend geschickt und als Antwort wird der gemessene Bitstring zurückgeschickt. Die Variabeln dieser Komponente sind: \\[3mm]
\begin{tabularx}{\textwidth}{p{3cm}p{11cm}} 
strLength & Die Länge des Bitstrings der für Bob berechnet werden soll. \\
rawPolarization & Alices Polarisation, als ein einzigen String. \\
polarization & Alices Polarisation, als Array von getrennten Polarisationen. \\
baseString &  Bobs Base, mit welcher die Photonen gemessen werden. \\
noise &  Das Rauschen, welche die Polarisationen bei der Übertragung gestört hat. \\
measuredString &  Der Rückgabewert, Bobs gemessener Bitstring. \\
bobBaseHasLoaded & Ein boolean, ob Bobs Base geladen ist (siehe oben, bei ButtonBobBase) \\
bobStringHasLoaded & Ein boolean, welcher auf true gesetzt wird, wenn der Bitstring gespeichert ist. \\
bobDataHasLoaded &  Ein boolean, welcher auf true gesetzt wird, wenn alle Daten von Bob gespeichert sind. \\
autostart & Ob die Komponente automatisch gestartet werden soll oder nicht. \\
text & Der Text, welcher auf dem Button erscheint.
\end{tabularx}
\item \texttt{ButtonShortenKey} \\
Eine Logik-Komponente, mit welcher die beiden Basen von Alice und Bob verglichen werden. Es werden die beiden Basen und die beiden Bitstrings per POST-methode an das backend geschickt und als Antwort wird die gekürzte Base zurückgeschickt. Zusätzlich werden auch die dadurch gekürzten Bitstrings von Alice und Bob und deren Länge zurückgeschickt. Dieser Komponente besitzt die folgenden Variabeln:\\[3mm]
\begin{tabularx}{\textwidth}{p{3cm}p{11cm}} 
baseString1 & Dies ist Alices Base, welche mitgeschickt wird. \\
baseString2 & Dies ist Bobs Base, welche mitgeschickt wird. \\
bitString1 & Dies ist Alices Bitstring, welcher mitgeschickt wird. \\
bitString2 &  Dies ist Bobs Bitstring, welcher mitgeschickt wird. \\
comparedBase & Ein Rückgabewert, die verglichene Base, welche mit \'1\' eine Übereinstimmung von zwei Einsen an dieser Stelle, mit \'0\' eine Übereinstimmung von zwei Nullen an dieser Stelle und mit \'\_\' keine Übereinstimmung an dieser Stelle codiert. \\ 
comparedBaseHasLoaded &  Ein boolean, welcher auf true gesetzt wird, wenn die verglichene Base gespeichert wurde \\
commonKeyAlice &  Alices gekürzter Bitstring, bei dem alle Stellen gestrichen wurden, an denen Alices und Bobs Basen nicht übereinstimmten. \\
commonKeyBob & Bobs gekürzter Bitstring, bei dem alle Stellen gestrichen wurden, an denen Alices und Bobs Basen nicht übereinstimmten. \\
commonKeyHasLoaded &  Ein boolean, welcher auf true gesetzt wird, wenn die gekürzten Bitstrings gespeichert wurden \\
commonKeyLength &  Die Länge des gekürzten Schlüssels als Ganzzahl \\
text &  Der Text, welcher auf dem Button erscheint.
\end{tabularx}
\item \texttt{PhotonGridSingle} \\
Wie PhotonGridDouble, (siehe weiter oben), rendert aber nur einen String anstatt zwei. \\
\item \texttt{ButtonCompareKey} \\
Eine Logik-Komponente, welche eine gewählte Anzahl (ein Verhältnis) von Stellen in den Bitstrings von Alice und Bob auf Übereinstimmung vergleicht. Diese nimmt als Argumente Alices Bitstring, Bobs Bitstring und das Verhältnis entgegen. Diese Argumente werden via POST-methode an das backend geschickt und dort miteinander verglichen. Alle verglichenen Stellen werden aus den Bitstrings entfernt und die so verarbeiteten Bitstrings werden an das frontend zurückgeschickt. Die Variabeln dieses Komponentes sind:
\begin{tabularx}{\textwidth}{p{3cm}p{11cm}} \\
bitString1 &  Dies ist Alices Bitstring, welcher mitgeschickt wird. \\
bitString2 &  Dies ist Bobs Bitstring, welcher mitgeschickt wird. \\
percentage &  Die Anzahl (Verhältnis 0\% bis 100\%) der Stellen in den Bitstrings, die verglichen werden \\
restKeyAlice &  Alices um die verglichenen Stellen gekürzter Key \\
restKeyBob &  Bobs um die verglichenen Stellen gekürzter Key \\
match & Das Verhältnis (0\% - 100\%) der Stellen, die übereingestimmt haben \\
restKeyHasLoaded &  Ein boolean, welcher auf true gesetzt wird, wenn die gekürzten Keys gespeichert wurden \\
restKeyLength &  Die Länge der beiden gekürzten Keys \\
text & Der Text, welcher auf dem Button erscheint.
\end{tabularx}
\item \texttt{EmojiComponent} \\
Eine kleine visuelle Komponente, die ein emoji rendert, um eine Stimmung auszudrücken.
\end{itemize}
\subsection{Ablauf}
\section{Vorgehensmodell}
Aufgrund der Aufgabenstellung empfiehlt sich ein hybrides Vorgehensmodell nach SODA. Ein Wasserfallmodell ist aus dem einfachen Grund ausgeschlossen, dass zum Zeitpunkt des Projektstarts der genaue Projektumfang noch nicht vorlag. Das Minimalziel liegt in der Umsetzung der Minimalanforderung, i.e. ein Schulbeispiel des BB84-Prototkolls. Die weiteren Punkte während der Projektverlaufs fortwährend festgelegt. 


\subsection{Architektur}
\subsubsection{Frontend}
\subsubsection{Backend}
Im Backend residiert ein Tomcat-Server. 
\subsection{Deployment}
Die ganze Applikation ist als Docker-Image verfügbar. Die Installation setzt also einen Docker-Client und eine Unix / Linux-Maschine voraus. Danach kann das Skript \texttt{install-docker.sh}-File ausgeführt werden. 

\section{Evaluation, Testing und Validation}
\subsection{Automatisierte Tests}
\subsection{Usertests}
\section{Ausblick}
Framing: Priorisiert, auch interessant, naheliegend, nicht blosse Ansammlung von Ideen. 

\newpage
\nocite{*}	
\bibliography{bibliographie}
\bibliographystyle{gerplain} 




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\end{document}


.